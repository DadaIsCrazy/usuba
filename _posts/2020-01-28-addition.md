---
layout: post
title: Bitslice adder
date: "2020-01-28 00:00:00"
description: Comparaison of native addition and a bitslice adder
lang: en
locale: en_US
author: Darius Mercadier
excerpt: Bitslicing is supposedly slow when it comes to arithmetic operations, since bitsliced program need to manually reimplement arithmetic using logical gates. In this post, we will show how much of a slowdown this would incur on an Intel Skylake CPU.
comments: false
hidden: true
---


As mentionned in
post
[2 - Bitslicing]({{ site.baseurl }}{% post_url 2020-01-14-bitslicing %}),
bitsliced codes cannot use arithmetic instructions. Instead,
arithmetic must be reimplemented using logical gates. To do an _n_-bit
addition for instance, a _n_-bit adder must be implement from _n_ full
adders. A full adder takes two 1-bit inputs (_A_ and _B_) and a carry
(_Cin_), and returns the sum of _A_ and _B_ (_s_), as well as the new
carry (_Cout_):


<p align="center"> 
<img src="{{ site.baseurl }}/assets/images/blog/adder/adder.png">
</p>

The simplest adder, the ripple-carry adder, is simply a chain of such
adders:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/carry-ripple-adder-small.png">
</p>

A _n_-bit ripple-carry adder contains _n_ full adder, each full adder
contains 5 instructions (3 `xor` and 2 `and`), or a total of _n*5_
instructions. While this represents a lot of instructions for a single
addition, using bitslicing, _m_-bit registers can be used, thus
computing _m_ additions in parallel, and reducing the cost to _n*5/m_
per addition. However, since modern high-end CPUs have a complex
superscalar microarchitecture, it's not obvious if this cost is high
or not. In this post, we will benchmark this adder against native
`add` instructions, and explain how to understand the results.


## Setup

<!-- Setup
  - loop X time over 1 addition
  - bitslice add
    + 8, 16, 32 bits: register pressure will matter at > 16
  - native add:
    + sse: 4x32, 8x16, 16x8
    + GP: 1x32, 1x16, 1x8
  - native add "parallel":
    + because superscalar: saturate p0156
  - Skylake i5-6500
-->

We will consider 3 different additions for our evaluation:

 - the bitslice adder presented above. Three variants will be used:
   8-bit, 16-bit and 32-bit. Since their number of instructions are
   _5*n_, we could expected the 32-bit adder to be twice slower than
   the 16-bit, which itself would be twice slower than the 8-bit
   adder. However, larger adder will put more pressure on registers,
   thus reducing performances.
   
 - an addition done using a single CPU instruction. We will consider
   the 8, 16 and 32-bit variants of the additions, all of which should
   have the same throughput and latency. On general purpose registers,
   only one addition can be done with a single instruction. However,
   SSE instructions allow to do 4 32-bit, or 8 16-bit or 16 8-bit
   additions with a single instruction. This does not reduce latency,
   but increase throughput.
 
 - Benchmarking 

instructions.


## Results

<!--
 - packed_single: 
   + expected: 1 add + 1 increment + 1 jump => 1 cycle
   + got: 1 cycle
 - packed_parallel:
   + expected: 3 add + 1 increment + 1 jump => 1 cycle
     * macro-fusion
   + got: 1 cycle
 - bitslice:
   + total ops: 5*n. 
   + expected: assuming 3 ops/cycle -> 5n/3
     * 8-bit: exp 8*5/3=13.3, got: 14.77, close enough!
     * 16-bit: exp 16*5/3=26.5, got: 33.28
       & 32-bit: exp 32*5/3=53.3, got: 74.55
       - spilling: half the instructions are `move`
 - bitslice vs others?
-->

<center>

<table style="border-collapse: collapse; text-align:center">
<tr style="border-top:1px solid #c6cbd1;border-right:1px solid #c6cbd1;border-left:1px solid #c6cbd1;background-color:#ffffff">
<th rowspan="2" style="min-width:250px">addition type</th><th style="min-width:200px">cycles/loop</th><th style="min-width:200px">cycles/add</th></tr>
<tr style="border-bottom:1px solid #c6cbd1;border-right:1px solid #c6cbd1;border-left:1px solid #c6cbd1;background-color:#ffffff"><th>(SSE / GP)</th><th>(SSE / GP)</th></tr>


<tr style="border:1px solid #c6cbd1;background-color:#e6f7ff"><td style="border:1px solid #c6cbd1">  8-bit        bitslice </td><td style="border:1px solid #c6cbd1">     14.77    /    16.28     </td><td style="border:1px solid #c6cbd1">      0.12    /     0.51     </td></tr> 
<tr style="border:1px solid #c6cbd1;background-color:#ffffff"><td style="border:1px solid #c6cbd1">  8-bit   packed_single </td><td style="border:1px solid #c6cbd1">      1.00    /     1.00     </td><td style="border:1px solid #c6cbd1">      0.06    /     1.00     </td></tr> 
<tr style="border:1px solid #c6cbd1;background-color:#e6f7ff"><td style="border:1px solid #c6cbd1">  8-bit packed_parallel </td><td style="border:1px solid #c6cbd1">      1.00    /     1.00     </td><td style="border:1px solid #c6cbd1">      0.02    /     0.33     </td></tr> 
<tr style="border:1px solid #c6cbd1;height:15px;background-color:#ffffff"><td></td><td></td><td></td></tr>


<tr style="border:1px solid #c6cbd1;background-color:#e6f7ff"><td style="border:1px solid #c6cbd1"> 16-bit        bitslice </td><td style="border:1px solid #c6cbd1">     33.28    /    34.52     </td><td style="border:1px solid #c6cbd1">      0.26    /     1.08     </td></tr> 
<tr style="border:1px solid #c6cbd1;background-color:#ffffff"><td style="border:1px solid #c6cbd1"> 16-bit   packed_single </td><td style="border:1px solid #c6cbd1">      1.00    /     1.00     </td><td style="border:1px solid #c6cbd1">      0.13    /     1.00     </td></tr> 
<tr style="border:1px solid #c6cbd1;background-color:#e6f7ff"><td style="border:1px solid #c6cbd1"> 16-bit packed_parallel </td><td style="border:1px solid #c6cbd1">      1.00    /     1.00     </td><td style="border:1px solid #c6cbd1">      0.04    /     0.33     </td></tr> 
<tr style="border:1px solid #c6cbd1;height:15px;background-color:#ffffff"><td></td><td></td><td></td></tr>


<tr style="border:1px solid #c6cbd1;background-color:#e6f7ff"><td style="border:1px solid #c6cbd1"> 32-bit        bitslice </td><td style="border:1px solid #c6cbd1">     74.55    /    73.33     </td><td style="border:1px solid #c6cbd1">      0.58    /     2.29     </td></tr> 
<tr style="border:1px solid #c6cbd1;background-color:#ffffff"><td style="border:1px solid #c6cbd1"> 32-bit   packed_single </td><td style="border:1px solid #c6cbd1">      1.00    /     1.00     </td><td style="border:1px solid #c6cbd1">      0.25    /     1.00     </td></tr> 
<tr style="border:1px solid #c6cbd1;background-color:#e6f7ff"><td style="border:1px solid #c6cbd1"> 32-bit packed_parallel </td><td style="border:1px solid #c6cbd1">      1.00    /     1.00     </td><td style="border:1px solid #c6cbd1">      0.08    /     0.33     </td></tr>

</table>

</center>

## Conclusion
