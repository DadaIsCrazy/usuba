---
layout: post
title: Usubac front-end
date: "2020-02-24 00:00:00"
description: The frontend of Usuba
lang: en
locale: en_US
author: Darius Mercadier
excerpt: 
comments: false
hidden: true
---

Usuba's compiler, Usubac, consists of two phases: the front-end, whose
role is to distill Usuba's high-level constructs into a minimal core
language, and the back-end, which performs optimizations over the core
language. The core language, called Usuba0, amounts to dataflow graphs
of Boolean and arithmetic operators. In its final pass, the back-end
translate Usuba0 to C code with intrinsics. The whole pipeline is
shown bellow:

<p align="center" style="margin-top:30px;margin-bottom:30px">
<img src="{{ site.baseurl }}/assets/images/blog/usuba-pipeline-small.png">
</p>

In this post, we will present the front-end. The back-end will be
presented in a later post. The "Masking" and "tightPROVE<sup>+</sup>"
passes add countermeasures against power-based side-channel attacks in
the codes generated by Usubac. They are both optional, and will be
discussed in a separate post.


The front-end extends the usual compilation pipeline of synchronous
dataflow languages [1, 2], namely normalization and scheduling, with
domain-specific transformations. Normalization enforces that, aside
from nodes, equations are restricted to defining variables at integer
type. Scheduling checks that a given set of equations is well-founded
and constructively provides an ordering of equations for which a
sequential execution yields a valid result. In our setting, scheduling
has to be further refined to produce high-performance code: scheduling
belongs to the compiler's back-end.

Several features of Usuba requires specific treatment by the
front-end. First, the language offers domain-specific syntax for
specifying cryptographic constructs such as lookup tables or
permutations. We boil these constructs down to Boolean circuits (see
post [5 - Usuba]({{ site.baseurl }}{% post_url 2020-02-24-usuba
%})). Second, the language provides a limited form of parametric
polymorphism while offering an overloading mechanism for logical and
arithmetic operations based on ad-hoc polymorphism. We produce
monomorphic code, with types and operations being expanded to machine
baked instructions for the target architecture and parallelism
discipline.

### Vectors

#### Operations on vectors

As shown in post [5 - Usuba]({{ site.baseurl }}{% post_url
2020-02-24-usuba %}), logical and arithmetic operations applied to
vectors are unfolded. For instance, the last instruction of Rectangle
is:

```lustre
cipher = round[25] ^ key[25]
```

Where `cipher`, `round[25]` and `keys[25]` are all of type
`u16[4]`. Thus, this operations is expanded by the front-end to:

```lustre
cipher[0] = round[25][0] ^ key[25][0]
cipher[1] = round[25][1] ^ key[25][1]
cipher[2] = round[25][2] ^ key[25][2]
cipher[3] = round[25][3] ^ key[25][3]
```

Shifts and rotations involving vectors are performed by the front-end
alltogether. For instance, the `ShiftRows` node of Rectangle contains
the following rotation:

```lustre
out[1] = input[1] <<< 1;
```

In bitslice mode, `out[1]` and `input[1]` are both vectors of type
`b1[16]`. Usubac thus applies the rotation and this instruction
becomes:

```lustre
out[1] = (input[1][1],  input[1][2],  input[1][3],  input[1][4], 
          input[1][5],  input[1][6],  input[1][7],  input[1][8], 
          input[1][9],  input[1][10], input[1][11], input[1][12], 
          input[1][13], input[1][14], input[1][15], input[1][0])
```

#### Vector assignments

Assignments between vectors are expanded into assignments from atoms
to atoms. This serves three purposes: first, Usubac will eventually
generate C code, which does not not support vector assignment. Second,
this makes optimizations easier; in particular copy propagation and
common subexpression elimination. Third, doing this before the
scheduling pass (which belongs to the back-end) allows a vector
assignment to be scheduled non-contiguously, which improves
performances in some cases. The previous example is thus turned into:


```lustre
(out[1][0],  out[1][1],  out[1][2],  out[1][3], 
 out[1][4],  out[1][5],  out[1][6],  out[1][7], 
 out[1][8],  out[1][9],  out[1][10], out[1][11], 
 out[1][12], out[1][13], out[1][14], out[1][15]) =
         (input[1][1],  input[1][2],  input[1][3],  input[1][4], 
          input[1][5],  input[1][6],  input[1][7],  input[1][8], 
          input[1][9],  input[1][10], input[1][11], input[1][12], 
          input[1][13], input[1][14], input[1][15], input[1][0])
```

Which is then expanded into:

```lustre
out[1][0]  = input[1][1];
out[1][1]  = input[1][2];
out[1][2]  = input[1][3];
out[1][3]  = input[1][4];
out[1][4]  = input[1][5];
out[1][5]  = input[1][6];
out[1][6]  = input[1][7];
out[1][7]  = input[1][8];
out[1][8]  = input[1][9];
out[1][9]  = input[1][10];
out[1][10] = input[1][11];
out[1][11] = input[1][12];
out[1][12] = input[1][13];
out[1][13] = input[1][14];
out[1][14] = input[1][15];
out[1][15] = input[1][0];
```

#### Node calls

In order to reduce the size of the codes we generate 

### Monomorphization

The parametric polymorphism offered by Usuba enables the concise
description of size-generic or direction-generic algorithms. The
choice of execution model can thus be postponed to
compile-time. However, the code generated by Usuba must be
monomorphic. Striving for performance, we cannot afford to manipulate
boxed values at run-time. Also, the underlying SIMD architecture does
not allow switching between a vertical or horizontal style of SIMD
operations. The Usubac compiler provides flags `-H` and `-V` to
monomorphize the main node to the corresponding horizontal or vertical
direction, while the `-m m` flag monomorphizes the atomic word size to
the given positive integer `m`.  

Crucially, we do not implement ad-hoc polymorphism by dictionary
passing [3], which would imply a run-time overhead, but resort to
static monomorphization [4]. Provided that type-checking was
successful, we know precisely which operator instance exists at the
given type and macro-expand it.

### Flattening from m-slicing to bitslicing. 

We may also want to flatten an _m_-sliced cipher to a purely bitsliced
model.  Performance-wise, it is rarely (if ever) interesting: the
higher register pressure imposed by bitslicing is too detrimental.
However, some architectures (such as 8-bit micro-controllers) do not
offer vectorized instruction sets at all. Also, bitsliced algorithms
can serve as the basis for hardening software implementations against
fault attacks [5, 6]. To account for these use-cases, Usuba can
automatically flatten a cipher into bit-sliced form. Flattening is a
whole-program transformation (triggered by passing the flag `-B` to
Usubac) that globally rewrites all instances of vectorial types
`u<D>m×n` into the type `bm[n]`. Note that the vectorial direction of
the source is irrelevant: it will be collapsed after flattening. The
rest of the source code is processed as-is: we rely solely on ad-hoc
polymorphism to drive the elaboration of the operators at the
rewritten types. Either type checking (and, therefore, type-class
resolution) succeeds, in which case we have obtained the desired
bitsliced implementation, or type-class resolution fails, meaning that
the given program exploits operators that are not available in
bitsliced form. For instance, short of providing an arithmetic
instance on `b8`, we will not be able to bitslice an algorithm relying
on addition on `u<V>8`.

Once again, we rely on ad-hoc polymorphism to capture (in a single
conceptual framework) the fact that a given program may or may not be
amenable to bitslicing. The user is thus presented with a meaningful
type error, which points out exactly which operator is incompatible
with (efficient) bitslicing.

### Usuba0

The front-end produces a monomorphic dataflow graph whose nodes
correspond to logical and arithmetic operations provided by the target
instruction set. This strict subset of the Usuba language is called
Usuba0. It translates almost directly to C: in principle, we only need
to schedule the code after which each equation turns into a variable
assignment of an integer type. Nodes are translated to function
definitions whereas node calls translate to function calls. However,
the Usuba0 code produced by the front-end is subjected to several
optimizations before delivery to a C compiler. We shall describe these
transformations in the next post.


---

## References

[1] D. Biernacki _et al._, [Clock-directed modular code generation for synchronous data-flow languages](https://www.di.ens.fr/~pouzet/bib/lctes08a.pdf), LCTES, 2008.

[2] F. Rocheteau, [Extension du langage LUSTRE et application à la conception de circuits : le langage LUSTRE-V4 et le système POLLUX](https://tel.archives-ouvertes.fr/tel-00342092) (Extension of the lustre language and application to hardware design: the lustre-v4 language and the pollux system), 1992.

[3] P. Wadler, S. Blott, [How to Make ad-hoc Polymorphism Less ad-hoc](https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf), POPL, 1988.

[4] S. Kaes, [Parametric Overloading in Polymorphic Programming Languages](https://link.springer.com/content/pdf/10.1007/3-540-19027-9_9.pdf),  ESOP, 1988.

[5] B. Lac _et al._, [Thwarting Fault Attacks against Lightweight Cryptography using SIMD Instructions](https://hal-cea.archives-ouvertes.fr/cea-01746138/document), ISCAS, 2018.

[6] C. Patrick, [Lightweight Fault Attack Resistance in Software Using Intra-instruction Redundancy](https://eprint.iacr.org/2016/850.pdf), SAC, 2016.
