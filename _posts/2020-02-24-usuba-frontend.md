---
layout: post
title: Usubac front-end
date: "2020-02-24 00:00:00"
description: The frontend of Usuba
lang: en
locale: en_US
author: Darius Mercadier
excerpt: 
comments: false
hidden: true
---

The Usubac compiler consists of two phases: the front-end, whose role
is to distill Usuba's high-level constructs into a minimal core
language, and the back-end, which performs optimizations over the core
language. The core language, called Usuba0, amounts to dataflow graphs
of Boolean and arithmetic operators. In its final pass, the back-end
translate Usuba0 to C code with intrinsics.


The front-end extends the usual compilation pipeline of synchronous dataflow languages [16, 69], namely normalization and scheduling, with domain-specific transformations. Normalization enforces that, aside from nodes, equations are restricted to defining variables at integer type. Scheduling checks that a given set of equations is well-founded and constructively provides an ordering of equations for which a sequential execution yields a valid result. In our setting, scheduling has to be further refined to produce high-performance code: scheduling belongs to the compiler's back-end. Several features of Usuba requires specific treatment by the front-end. First, the language offers domain-specific syntax for specifying cryptographic constructs such as lookup tables or permutations. We boil these constructs down to Boolean circuits. Second, the language provides a limited
form of parametric polymorphism while offering an overloading mechanism for logical and arithmetic operations based on ad-hoc polymorphism. We produce monomorphic code, with types and operations being expanded to machine baked instructions for the target architecture and parallelism discipline.

### Monomorphization

The parametric polymorphism offered
by Usuba enables the concise description of size-generic or
direction-generic algorithms. The choice of execution model
can thus be postponed to compile-time. However, the code
generated by Usuba must be monomorphic. Striving for per-
formance, we cannot afford to manipulate boxed values at
run-time. Also, the underlying SIMD architecture does not al-
low switching between a vertical or horizontal style of SIMD
operations. The Usubac compiler provides flags -H and -V to
monomorphize the main node to the corresponding horizon-
tal or vertical direction, while the -w m flag monomorphizes
the atomic word size to the given positive integer m.
Crucially, we do not implement ad-hoc polymorphism
by dictionary passing [71], which would imply a run-time
overhead, but resort to static monomorphization [36]. Pro-
vided that type-checking was successful, we know precisely
which operator instance exists at the given type and macro-
expand it.

### Flattening

from m-slicing to bitslicing. We may also want
to flatten an m-sliced cipher to a purely bitsliced model.
Performance-wise, it is rarely (if ever) interesting: the higher
register pressure imposed by bitslicing is too detrimental.
However, some architectures (such as 8-bit micro-controllers)
do not offer vectorized instruction sets at all. Also, bitsliced
algorithms serve as the basis for hardening software imple-
mentations against fault attacks [45, 64]. To account for these
use-cases, Usuba can automatically flatten a cipher into bit-
sliced form. Flattening is a whole-program transformation
(triggered by passing the flag -B to Usubac) that globally
rewrites all instances of vectorial types u D m Ã— n into the
type bm[n]. Note that the vectorial direction of the source
is irrelevant: it will be collapsed after flattening. The rest of
the source code is processed as-is: we rely solely on ad-hoc
polymorphism to drive the elaboration of the operators at
the rewritten types. Either type checking (and, therefore,
type-class resolution) succeeds, in which case we have ob-
tained the desired bitsliced implementation, or type-class
resolution fails, meaning that the given program exploits op-
erators that are not available in bitsliced form. For instance,
short of providing an arithmetic instance on b8, we will not
be able to bitslice an algorithm relying on addition on u V 8.
Once again, we rely on ad-hoc polymorphism to capture
(in a single conceptual framework) the fact that a given
program may or may not be amenable to bitslicing. The user
is thus presented with a meaningful type error, which points
out exactly which operator is incompatible with (efficient)
bitslicing.

### Usuba0

The front-end produces a monomorphic dataflow
graph whose nodes correspond to logical and arithmetic op-
erations provided by the target instruction set. This strict
subset of the Usuba language is called Usuba0. It translates
almost directly to C: in principle, we only need to schedule
the code (as described in the following Section) after which
each equation turns into a variable assignment of an integer
type. Nodes are translated to function definitions whereas
node calls translate to function calls. However, the Usuba0
code produced by the front-end is subjected to several opti-
mizations before delivery to a C compiler. We describe these
transformations in the following Section.
