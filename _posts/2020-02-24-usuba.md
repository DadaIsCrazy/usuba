---
layout: post
title: Usuba
date: "2020-02-24 00:00:00"
description: The Usuba language
lang: en
locale: en_US
author: Darius Mercadier
excerpt: The Usuba language is driven by a combination of algorithmic and hardware-specific constraints. To get high throughput, we focus exclusively on parallel modes of operation such as counter mode (CTR).We translate this constraint by forbidding feedback loops in our designs. An Usuba program can therefore be understood as a stateless combinational circuit, parallelizable by design.
comments: true
hidden: false
--- 

The Usuba language design is driven by a combination of algorithmic
and hardware-specific constraints: implementing a block cipher
requires some discipline to achieve high throughput and avoid timing
attacks. 

Timing attacks can have two main causes: conditional based on secret
data, and memory accesses based on secret data. The first one is not
an issue for block ciphers, since they never rely on conditional based
on secret data. We translate this in Usuba by simply not including a
conditional operator in the language. The second cause on the other
hand is nullified by the slicing Usuba relies on: both bitslicing and
mslicing prevent the use of memory accesses based on conditional data.

To get high throughput, we focus exclusively on block ciphers, and
assumes that they are used in a parallelizable mode (_e.g._ CTR). We
translate this constraint by forbidding feedback loops in our
designs. An Usuba program can therefore be understood as a stateless
combinational circuit, parallelizable by design.

Usuba must be expressive enough to describe hardware-oriented ciphers,
such as DES or Trivium, which are specified in terms of Boolean
operations. For instance, the first operation of DES is defined as the
following 64-bit bit-permutation applied to the plaintext:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/des-init-perm-small.png">
</p>

To account for such ciphers, Usuba provides abstractions to manipulate
bitvectors, such as extracting a single bit as well as splitting or
combining vectors.

Finally, Usuba must also be able to describe software-oriented ciphers
specified in terms of affine transformations, such as AES and, more
generally, ciphers exploiting maximum distance separable matrices
[1]. For instance, one of AES's underlying functions (`MixColumns`)
multiplies the plaintext, seen as a 4x4 matrix, with a constant
matrix:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/aes-mixcolumns-small.png">
</p>

Where the a<sub>i,j</sub> represent the 16 bytes of plaintext. To
account for such ciphers, Usuba handles the matricial structure of
each block of data, allowing bit-level operations to carry over such
structured types while driving the compiler into generating efficient
SIMD code.  Altogether, Usuba provides a vector-based programming
model, allowing us to work at the granularity of a single bit while
providing static type-checking and compilation to efficient code.

Usuba programs are also subject to architecture-specific
constraints. For instance, a cipher relying on 32-bit multiplication
is but a poor candidate for bitslicing: this multiplication turns into
a genuine multiplier circuit simulated in software. Similarly, a
cipher relying on 6-bit arithmetic would be impossible to execute in
vertical slicing: the SIMD instruction sets manipulate bytes as well
as 16-bit, 32-bit and 64-bit words, leaving aside such an exotic
word-size. We are therefore in a rather peculiar situation where, on
the one hand, we would like to implement a cipher once, while, on the
other hand, the validity of our program depends on a combination of
slicing mode and target architecture.

How can we, at compile time, provide meaningful feedback to the Usuba
programmer so as to (always) generate high-throughput code? We address
this issue by introducing a type for structured blocks (Section Data
Layout) upon which we develop a language (Section Syntax & Semantics)
supporting parametric polymorphism (for genericity) and ad-hoc
polymorphism (for architecture-specific code generation) as well as a
type system (Section Type System) ensuring that "well-typed programs
do always vectorize".

### Data Layout

Our basic unit of computation is the block, *i.e.* a bitvector of
statically-known length. To account for its matricial structure and
its intended parallelization, we introduce the type `u<D>m×n` to denote
_n_ ∈ ℕ* registers of unsigned _m_-bit words (_m_ ∈ ℕ* and "u" stands for
"unsigned") that we intend to parallelize using vertical (_D_ = _V_) or
horizontal (_D_ = _H_) SIMD instructions. A single m-bit value is thus
typed `u<D>m×1`, abbreviated `u<D>m`. This notation allows us to
unambiguously specify the data layout of the blocks processed by the
cipher. Consider the 64-bit input block of the Rectangle cipher:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/rect-data-init.png">
</p>

Bitsliced Rectangle manipulates blocks of type <code>u&lt;<i
style="color:red">‘D</i>&gt;1×64</code>, i.e. each bit is dispatched
to an individual register:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/rect-data-bs.png">
</p>

A 16-bit vertical slicing implementation of Rectangle manipulates
blocks of type `u<V>16×4`, _i.e._ each one of the 4 sub-blocks is
dispatched to the first 16-bit element of 4 registers:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/rect-data-vs.png">
</p>

The double vertical lines represent the end of each 16-bit packed
elements. Horizontally sliced Rectangle has type `u<H>16×4`, _i.e._
each 16-bit word is horizontally spread across each of the 16 packed
elements of 4 SIMD registers:

<p align="center">
<img src="{{ site.baseurl }}/assets/images/blog/rect-data-hs.png">
</p>

Note that directions collapse in the case of bitslicing, _i.e._
`u<V>1×64` ≅ `u<H>1×64`. Both cases amount to the same layout, or put
otherwise: vertical and horizontal slicing are two generalizations of
bitslicing.

For a given data layout, throughput is maximized by filling the
remaining bits (in grey on the figures) of the registers with
subsequent blocks of the input stream, following the same
pattern. Thus, a vertical, 16-bit SIMD addition (_e.g._ `vpaddw` on
AVX) in vertical slicing will amount to performing an addition on 8
blocks in parallel. We emphasize that the types merely describe the
structure of the blocks, and do not specify the parallelization
strategy, nor the architecture to be used. An Usuba program thus only
specifies the treatment of a single slice, from which Usuba's compiler
automatically generates code to maximize register usage. Transposing
a sequence of input blocks in a form suitable for parallel processing
is thus fully determined by its type. 


### Syntax & Semantics 

In and of itself, Usuba is an unsurprising dataflow language [3,
4]. We use the example of Rectangle to illustrate Usuba's syntax and
semantics:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">table</span> <span class="nf">SubColumn</span> <span class="p">(</span><span class="n">in</span><span class="o">:</span><span class="k">v4</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="k">v4</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">6</span> <span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span>
    <span class="mi">11</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">node</span> <span class="nf">ShiftRows</span> <span class="p">(</span><span class="n">input</span><span class="o">:</span><span class="k">u16</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="k">returns</span> <span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="k">u16</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="k">let</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">13</span>
<span class="k">tel</span>

<span class="k">node</span> <span class="nf">Rectangle</span> <span class="p">(</span><span class="n">plain</span><span class="o">:</span><span class="k">u16</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">,</span><span class="n">key</span><span class="o">:</span><span class="k">u16</span><span class="p">[</span><span class="mi">26</span><span class="p">][</span><span class="mi">4</span><span class="p">])</span>
       <span class="k">returns</span> <span class="p">(</span><span class="n">cipher</span><span class="o">:</span><span class="k">u16</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="k">vars</span> <span class="n">round</span> <span class="o">:</span> <span class="k">u16</span><span class="p">[</span><span class="mi">26</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
<span class="k">let</span>
    <span class="n">round</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">plain</span><span class="p">;</span>
    <span class="n">forall</span> <span class="n">i</span> <span class="n">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">24</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">round</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShiftRows</span><span class="p">(</span><span class="n">SubColumn</span><span class="p">(</span><span class="n">round</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="p">}</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">round</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span>
<span class="k">tel</span>
</code></pre></div></div>

In the following, we shall leave types and typing aside, coming back
to this point in the next section. 


**Nodes**

An Usuba program is composed of a totally ordered set of nodes
(`SubColumn`, `ShiftRows` and `Rectangle` in the case of
Rectangle). The last node plays the role of the main entry point: it
will be compiled to a C function. The compiler is left free to compile
internal nodes to functions or to inline them. A node typically
consists of an unordered system of equations involving logic and
arithmetic operators. The semantics is defined extensionally as a
solution to the system of equations, _i.e._ an assignment of variables
to values such that all the equations hold.

Usuba also provides syntactic sugar for declaring lookup tables,
useful for specifying S-boxes. Rectangle's S-box can thus be written
as:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">table</span> <span class="nf">SubColumn</span> <span class="p">(</span><span class="n">in</span><span class="o">:</span><span class="k">v4</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="k">v4</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">6</span> <span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span>
    <span class="mi">11</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></div></div>


Conceptually, a lookup table is an array: a _n_-bit input indexes into
an array of 2ⁿ possible output values. However, to maximize throughput
and avoid cache timing attacks, the compiler expands lookup tables to
Boolean circuits. For prototyping purposes, Usuba uses an elementary
logic synthesis algorithm based on binary decision diagrams (BDD)
–inspired by [5]– to perform this expansion. The circuits generated by
this tool are hardly optimal: finding optimal representations of
S-boxes is a full time occupation for cryptographers, often involving
months of exhaustive search [6, 7, 8, 9].  Usuba integrates these
hard-won results into a database of known circuits, which is searched
before trying to convert any lookup table to a circuit. For instance,
Rectangle’s S-box (`SubColumn`) is replaced by the compiler with the
following node:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">node</span> <span class="nf">SubColumn</span> <span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="k">v4</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">b</span><span class="o">:</span><span class="k">v4</span><span class="p">)</span>
  <span class="k">vars</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">,</span><span class="n">t3</span><span class="o">,</span><span class="n">t4</span><span class="o">,</span><span class="n">t5</span><span class="o">,</span><span class="n">t6</span><span class="o">,</span><span class="n">t7</span><span class="o">,</span><span class="n">t8</span><span class="o">,</span><span class="n">t9</span><span class="o">,</span><span class="n">t10</span><span class="o">,</span><span class="n">t11</span><span class="o">,</span><span class="n">t12</span> <span class="o">:</span> <span class="k">v1</span>
  <span class="k">let</span> 
    <span class="n">t1</span>   <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> 
    <span class="n">t2</span>   <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">t1</span><span class="p">;</span> 
    <span class="n">t3</span>   <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">^</span> <span class="n">t3</span><span class="p">;</span> 
    <span class="n">t5</span>   <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">t1</span><span class="p">;</span> 
    <span class="n">t6</span>   <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">t5</span><span class="p">;</span> 
    <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">t6</span><span class="p">;</span> 
    <span class="n">t8</span>   <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> 
    <span class="n">t9</span>   <span class="o">=</span> <span class="n">t3</span> <span class="o">&amp;</span> <span class="n">t6</span><span class="p">;</span> 
    <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">t8</span> <span class="o">^</span> <span class="n">t9</span><span class="p">;</span> 
    <span class="n">t11</span>  <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">t8</span><span class="p">;</span> 
    <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">t6</span> <span class="o">^</span> <span class="n">t11</span>
<span class="k">tel</span>
</code></pre></div></div>

Bit-permutations are commonly used in cryptographic algorithm to
provide diffusion. Usuba offers syntactic support for declaring
bit-permutations. For instance, the initial permutation of DES
mentioned in the introduction of this post amounts to the following
declaration specifying which bit of the input bitvector should be
routed to the corresponding position of the output bitvector:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">perm</span> <span class="n">init_p</span> <span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="n">b64</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span> <span class="n">out</span><span class="o">:</span><span class="n">b64</span> <span class="p">)</span> <span class="p">{</span>
     <span class="mi">58</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">26</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">52</span><span class="o">,</span> <span class="mi">44</span><span class="o">,</span> <span class="mi">36</span><span class="o">,</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span>
     <span class="mi">62</span><span class="o">,</span> <span class="mi">54</span><span class="o">,</span> <span class="mi">46</span><span class="o">,</span> <span class="mi">38</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">22</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">64</span><span class="o">,</span> <span class="mi">56</span><span class="o">,</span> <span class="mi">48</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">32</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span>
     <span class="mi">57</span><span class="o">,</span> <span class="mi">49</span><span class="o">,</span> <span class="mi">41</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">25</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">59</span><span class="o">,</span> <span class="mi">51</span><span class="o">,</span> <span class="mi">43</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">27</span><span class="o">,</span> <span class="mi">19</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span>
     <span class="mi">61</span><span class="o">,</span> <span class="mi">53</span><span class="o">,</span> <span class="mi">45</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">29</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">63</span><span class="o">,</span> <span class="mi">55</span><span class="o">,</span> <span class="mi">47</span><span class="o">,</span> <span class="mi">39</span><span class="o">,</span> <span class="mi">31</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">7</span>
<span class="p">}</span>
</code></pre></div></div>

It should be read as "the 1<sup>st</sup> bit of the output is the
58<sup>th</sup> bit of the input, the 2<sup>nd</sup> bit of the output
is the 50<sup>th</sup> of the input, _etc._".  The direct bitsliced
translation of this permutation is a function of 64 Boolean inputs and
64 Boolean outputs, which consists of simple assignments: `out[0] =
a[58]; out[1] = a[50]; ...` After Usuba's copy propagation pass, a
bit-permutation is thus no more than a (static) renaming of variables.


Finally, usuba also offers a way to define an array of nodes, tables
or permutations. For instance, the Serpent cipher uses a different
S-box for each round, all of which can be grouped into the same array
of tables:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">table[]</span> <span class="nf">sbox</span><span class="p">(</span><span class="n">input</span><span class="o">:</span><span class="n">v4</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="n">v4</span><span class="p">)</span> <span class="p">[</span>
    <span class="p">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span><span class="mi">12</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span><span class="mi">15</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span><span class="mi">14</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">13</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span> <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>

Those S-boxes can then be called using the following syntax:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">sbox</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span>)</code></pre></div></div>

The `3` can be replaced by any arithmetic expression. Arrays of
nodes/tables/permutations are especially useful to be used in `forall`
loops (introduced below). For instance, Serpent's main `forall` loop
contains:

```lustre
sbox<i%8>(...)
```

To call the _i_<sup>th</sup> S-box at the _i_<sup>th</sup> round
(modulo 8).


**Vectors**

Syntactically, our treatment of vectors stems from the work on
hardware synthesis of synchronous dataflow programs [10]. <!-- In effect,
we are merely describing "software circuits". Many programming idioms
found in hardware synthesis, which would be extremely inefficient in
general, can be efficiently implemented in our setting. For instance,
as shown in [Post 2: Bitslicing]({{ site.baseurl
}}{% post_url 2020-01-14-bitslicing %}), in bitsliced mode, 
permutations can be done at compile-time.-->  Given a vector `x` of size
_n_ (thus, of type `τ[n]`), we can obtain the element `x[k]` at
position 0 ≤ _k_ < _n_ and the consecutive elements `x[k..l]` in the
range 0 ≤ _k_ < _l_ < _n_. This syntax is instrumental for writing
concise bit-twiddling code. Indices must be known at compile-time,
since variable indices could compromise the constant-time property of
the code. The type-checker can therefore prevent out-of-bounds
accesses. Noticeably, vectors are maintained in a flattened
form. Given two vectors `x` and `y` of size, respectively, _m_ and
_n_, the variable `z = (x, y)` is itself a vector of size _m+n_ (not a
pair of vectors). Conversely, for a vector `u` of size _m+n_, the
equation `(x, y) = u` stands for `x = u[0..n]` and `y = u[n..m + n]`.

**Loops**

To account for repetitive definitions (such as the wiring of the 25
rounds of Rectangle), the `forall` construct lets us declare a group
of equations within static bounds. Its semantics is intuitively
defined by macro-expansion: we can always translate it into a chunk of
inter-dependent equations. However, in practice, Usuba's compiler
preserves this structure in its pipeline and may generate imperative
loops performing destructive updates. Serpent's main loop for instance
is:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">30</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">linear_layer</span><span class="p">(</span><span class="n">sbox</span><span class="o">&lt;</span><span class="n">i</span><span class="o">%</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="p">}</span></code></pre></div></div>
    
Each of the 31 iteration computes a round of Serpent: it xors the
result of the previous round (`state[i]`) with the key for this round
(`keys[i]`), then calls the S-box for this round (`sbox<i%8>`), and
finally calls the node `linear_layer` and stores the result in
`state[i+1]` for the next round. Since this loop relies on calling an
array of tables, and the notion of array of functions does not exists
in C, Usubac compiler has no choice but to fully unroll it.



**Imperative assignment**

Some ciphers (_e.g._ Chacha20, Serpent) are defined in an imperative
manner, repetitively updating a local state. Writing those ciphers in
a synchronous dataflow language can be tedious: it amounts to writing
code in static single assignment (SSA) form. To simplify such codes,
Usuba provides an assignment operator `x := e` (where `x` may appear
free in `e`). It desugars into a standard equation with a fresh
variable on the left-hand side that is substituted for the updated
state in later equations. For instance, Serpent's linear layer can be
written as:


<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">node</span> <span class="nf">linear_layer</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">u32x4</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="n">u32x4</span><span class="p">)</span>
<span class="k">let</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">13</span><span class="p">;</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;&lt;</span> <span class="mi">22</span><span class="p">;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">tel</span></code></pre></div></div>

Which desugars to:

```lustre
node linear_layer(x:u32x4) returns (out:u32x4)
vars t0, t1, t2, t3, t4, t5, t6, t7, t8, t9: u32
let
    t0 = x[0] <<< 13;
    t1 = x[2] <<< 3;
    t2 = x[1] ^ t0 ^ t1;
    t3 = x[3] ^ t1 ^ (t0 << 3);
    t4 = t2 <<< 1;
    t5 = t3 <<< 7;
    t6 = t0 ^ t4 ^ t5;
    t7 = t1 ^ t5 ^ (t4 << 7);
    t8 = t6 <<< 5;
    t9 = t7 <<< 22;
    out = (t8, t9, t4, t5);
tel
```



**Operators**

The constructs introduced so far deal with the wiring and structure of
the dataflow graph. To compute, one must introduce operators. Usuba
supports bitwise logical operators (conjunction `&`, disjunction `|`,
exclusive-or `^` and negation `~`), arithmetic operators (addition
`+`, multiplication `*` and subtraction `-`), shifts of vectors (left
`<<` and right `>>`), rotations of vectors (left `<<<` and right
`>>>`), and intra-register bit shuffling (`Shuffle`). Their
availability and exact implementation (especially, run-time cost)
depend on the slicing mode and the target architecture, as shown next.  

### Type System 

#### Base types

For the purpose of interacting with its cryptoraphic runtime, the
interface of a block cipher is specified in terms of the matricial
type `u<D>m×n`, which documents the layout of blocks coming in and out
of the cipher. We also have general vectors whose types are `τ[n]`,
for any type `τ`. Now, consider the subkeys used by vsliced Rectangle:
they are presented as an object key of type `u<V>16×4[26]`, which is
26 quadruples of 16-bit words. To obtain the key at round 23, we thus
write `key[23]`. To obtain the 3rd word of that key, we write
`key[23][3]`. The notation `u<D>m×4[26]` indicates that accesses must
be performed in column-major order, _i.e._ as if we were accessing an
object of type `u<D>m[26][4]` (following C convention). In fact,
because vectors are kept flat, the types `u<D>m[26][4]` and
`u<D>m×4[26]` are actually equivalent from the typechecker's
standpoint. This apparent redundancy is explained by the fact that
types serve two purposes. In the surface language, matricial types
(`u<D>m×4`) document the data layout and its SIMDization. In the
target language, the matricial structure is irrelevant: an object of
type `u<D>m×4[26]` supports exactly the same operations as an object
of type `u<D>m[26][4]`. Surface types are thus normalized, after
type-checking, into distilled types. A value of type `u<D>m×1` (for
all `D`) is called an atom, and its type is said to be atomic.


### Parametric polymorphism. 

A final addition to our language of types is the notion of parametric
word size and parametric direction. A cipher like Rectangle can in
fact be sliced horizontally or vertically: both modes of operation are
compatible with the various SIMD architectures introduced after
SSSE3. Similarly, the node `SubColumn` amounts to a Boolean circuit
whose operations (`&`, `|`, `^`, and `~`) are defined for any atomic
word size (ranging from a single Boolean to a 512-bit AVX512
register): `SubColumn` thus applies to `u<D>1`, `u<D>8`, etc. This
completes the grammar of distilled types, including type parameters in
word size and direction: 

<p style="margin:20px;margin-left:80px">

<b>n</b> ∈ ℕ <span style="display:inline-block;width:80px"></span>(integers)<br/>
<br/>
⟨<b>τ</b>⟩ ::=    <span style="display:inline-block;width:70px"></span> (types)<br/>
&nbsp;&nbsp;| u&lt;<b>D</b>&gt;⟨<b>m</b>⟩ <span style="display:inline-block;width:58px"></span>(base type)<br/>
&nbsp;&nbsp;| <b>τ</b>[<b>n</b>]       <span style="display:inline-block;width:70px"></span> (vectors)<br/>
&nbsp;&nbsp;| nat        <span style="display:inline-block;width:80px"></span> (static constants)<br/>
<br/>
⟨<b>m</b>⟩ ::=      <span style="display:inline-block;width:69px"></span> (size)<br/>
&nbsp;&nbsp;| <i style="color:red">‘m</i>         <span style="display:inline-block;width:85px"></span> (parameter)<br/>
&nbsp;&nbsp;| <b>n</b>          <span style="display:inline-block;width:95px"></span> (fixed size)<br/>
<br/>
⟨<b>D</b>⟩ ::=      <span style="display:inline-block;width:65px"></span> (direction)<br/>
&nbsp;&nbsp;| <i style="color:red">‘D</i>        <span style="display:inline-block;width:80px"></span> (parameter)<br/>
&nbsp;&nbsp;| V         <span style="display:inline-block;width:90px"></span> (vertical)<br/>
&nbsp;&nbsp;| B         <span style="display:inline-block;width:90px"></span> (horizontal)<br/>

</p>


Nodes being first-order functions, a function type is (at most) rank-1
polymorphic: the polymorphic parameters it may depend on are
universally quantified over the whole type (and node body). We use the
abbreviation `bn` (_n_ **b**its) and `um` (**u**nsigned integer of
size _m_) for the type <code>u&lt;<i
style="color:red">‘D</i>&gt;1×n</code> and, respectively,
<code>u&lt;<i style="color:red">‘D</i>&gt;m×1</code> where <i
style="color:red">‘D</i> is the direction parameter in the nearest
scope. Similarly, we write `vn` for <code>u&lt;<i
style="color:red">‘D</i>&gt;<i style="color:red">‘m</i>×n</code> when
<i style="color:red">‘m</i> is the nearest word size parameter.

### Ad-hoc polymorphism

In reality, few programs are defined for any word size or any
direction. Only Boolean circuits are direction polymorphic, bitwise
logical operations applying uniformly. Also, no program is absolutely
parametric in the word size: we can only compute up to the register
size of the underlying architecture.


To capture these invariants, we introduce a form of bounded
polymorphism through type-classes [11]. Whether a given cipher can be
implemented over a collection of word size and/or direction is
determined by the availability of logical and arithmetic operators. We
therefore introduce four type-classes for logical, arithmetic,
shift/rotate and shuffle operations:

```
Logic(τ) :          Arith(τ) :             Shift(τ) :
 & : τ → τ → τ        + : τ → τ → τ            >> : τ → nat → τ
 | : τ → τ → τ        * : τ → τ → τ            << : τ → nat → τ
 ^ : τ → τ → τ        - : τ → τ → τ           >>> : τ → nat → τ
 ~ : τ → τ                                    <<< : τ → nat → τ
 
Shuffle(τ) :
 Shuffle:  τ → nat list → τ
```

The implementation of these classes depend on the type considered and
the target architecture. For instance, arithmetic on 13-bit words is
impossible, even in vertical mode. The generated code also depends on
a combination of types and target architecture. For instance, shifting
a vector amounts to renaming registers whereas shifting in horizontal
mode requires an actual shuffle instruction. We chose to provide
instances solely for operations that can be implemented statically or
with a handful of instructions, with the exceptions of `Shuffle`,
which is made available in vertical mode despite its cost. Our
type-class mechanism is not user-extensible. The list of all the
possible type-classes instances is summarized in the following
table. This set of instances is obviously non-overlapping so our
overloading mechanism is coherent: if the type-checker succeeds in
finding an instance for the target architecture, then that instance is
unique.


<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;margin-left:auto;margin-right:auto;margin-bottom:20px;margin-top:20px}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:center;vertical-align:middle}
.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-73oq{border-color:#000000;text-align:center;vertical-align:middle}
.tg .tg-0a7q{border-color:#000000;text-align:center;vertical-align:middle}
.tg .tg-0lax{text-align:center;vertical-align:top}
.tg .tg-nrix{text-align:center;vertical-align:middle}
.tg .tg-lboi{border-color:inherit;text-align:center;vertical-align:middle}
.tg .tg-0pky{border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-c3ow">Class</th>
    <th class="tg-c3ow" colspan="2">Instances<br></th>
    <th class="tg-c3ow">Architecture<br></th>
    <th class="tg-c3ow">Compiled with</th>
  </tr>
  <tr>
    <td class="tg-9wq8" rowspan="2">Logic(<code>τ</code>)</td>
    <td class="tg-c3ow" colspan="2">Logic(<code>τ</code>) ⇒ Logic(<code>τ[<i>n</i>]</code>) <br>           for <i>n</i> ∈ ℕ</td>
    <td class="tg-9wq8">all</td>
    <td class="tg-73oq">homomorphic application (<i>n</i> instr.)</td>
  </tr>
  <tr>
    <td class="tg-c3ow" colspan="2">Logic(<code>u&lt;<i style="color:red">‘D</i>&gt;<i>m</i></code>) for <i>m</i> ∈ [1, 64]<br>Logic(<code>u&lt;<i style="color:red">‘D</i>&gt;<i>m</i></code>) for <i>m</i> ∈ [65, 128]<br>Logic(<code>u&lt;<i style="color:red">‘D</i>&gt;<i>m</i></code>) for <i>m</i> ∈ [129, 256]<br>Logic(<code>u&lt;<i style="color:red">‘D</i>&gt;<i>m</i></code>) for <i>m</i> ∈ [257, 512]</td>
    <td class="tg-c3ow">≥ x86-64<br>≥ SSE<br>≥ AVX<br>≥ AVX512<br></td>
    <td class="tg-0a7q"><code>and</code>, <code>or</code>, etc (1 instr.)</td>
  </tr>
  <tr>
    <td class="tg-9wq8" rowspan="2">Arith(<code>τ</code>)</td>
    <td class="tg-c3ow" colspan="2">Arith(<code>τ</code>) ⇒ Arith(<code>τ[<i>n</i>]</code>)<br>for <i>n</i> ∈ ℕ<br></td>
    <td class="tg-9wq8">all</td>
    <td class="tg-0a7q">homomorphic application (<i>n</i> instr.)</td>
  </tr>
  <tr>
    <td class="tg-c3ow" colspan="2">Arith(<code>u&lt;V&gt;8</code>)<br>Arith(<code>u&lt;V&gt;16</code>)<br>Arith(<code>u&lt;V&gt;32</code>)<br>Arith(<code>u&lt;V&gt;64</code>)</td>
    <td class="tg-9wq8">all</td>
    <td class="tg-0a7q"><code>add</code>, <code>vpadd</code>, <code>vpsub</code>, etc. (1 instr.)</td>
  </tr>
  <tr>
    <td class="tg-9wq8" rowspan="5">Shift(<code>τ</code>)</td>
    <td class="tg-c3ow" colspan="2">Shift(<code>τ[<i>n</i>]</code>) for <i>n</i> ∈ ℕ</td>
    <td class="tg-c3ow">all</td>
    <td class="tg-73oq">variable renaming (0 instr.)</td>
  </tr>
  <tr>
    <td class="tg-0lax" style="border-right:0">Shift(<code>u&lt;V&gt;<i style="color:red">‘m</i></code>),<br>Shift(<code>u&lt;H&gt;<i style="color:red">‘m</i></code>)<br></td>
    <td class="tg-cly1" style="border-left:0">⇒ Shift(<code>u&lt;‘<i>D</i>&gt;<i style="color:red">‘m</i></code>)</td>
    <td class="tg-nrix">all</td>
    <td class="tg-cly1">depends of instance</td>
  </tr>
  <tr>
    <td class="tg-0lax" colspan="2">Shift(<code>u&lt;V&gt;16</code>)<br>Shift(<code>u&lt;V&gt;32</code>)<br>Shift(<code>u&lt;V&gt;64</code>)</td>
    <td class="tg-cly1">all</td>
    <td class="tg-cly1"><code>vpsrl</code>/<code>vpsll</code> (≤ 3 instr.)</td>
  </tr>
  <tr>
    <td class="tg-0lax" colspan="2">Shift(<code>u&lt;H&gt;2</code>)<br>Shift(<code>u&lt;H&gt;4</code>)<br>Shift(<code>u&lt;H&gt;8</code>)<br>Shift(<code>u&lt;H&gt;16</code>)<br></td>
    <td class="tg-cly1">≥ SSE</td>
    <td class="tg-cly1" rowspan="2"><code>vpshuf</code> (1 instr.)</td>
  </tr>
  <tr>
    <td class="tg-0lax" colspan="2">Shift(<code>u&lt;H&gt;32</code>)<br>Shift(<code>u&lt;H&gt;64</code>)<br></td>
    <td class="tg-cly1">≥ AVX512</td>
  </tr>
  <tr>
    <td class="tg-lboi" rowspan="4">Shuffle(<code>τ</code>)</td>
    <td class="tg-0pky" colspan="2">Shuffle(<code>u&lt;H&gt;2</code>)<br>Shuffle(<code>u&lt;H&gt;4</code>)<br>Shuffle(<code>u&lt;H&gt;8</code>)<br>Shuffle(<code>u&lt;H&gt;16</code>)<br></td>
    <td class="tg-lboi">&gt;= SSE</td>
    <td class="tg-lboi" rowspan="2"><code>vpshuf</code> (1 instr.)</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="2">Shuffle(<code>u&lt;H&gt;32</code>)<br>Shuffle(<code>u&lt;H&gt;64</code>)<br></td>
    <td class="tg-lboi">&gt;= AVX512</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="2">Shuffle(<code>u&lt;V&gt;16</code>)<br>Shuffle(<code>u&lt;V&gt;32</code>)<br>Shuffle(<code>u&lt;V&gt;64</code>)</td>
    <td class="tg-lboi">all</td>
    <td class="tg-lboi" rowspan="2"><code>vpsrl</code>/<code>vpsll</code>/<code>vpand</code>/<code>vpxor</code><br> (<i>m * 4</i> instr.)</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="2">Shuffle(<code>u&lt;V&gt;8</code>)</td>
    <td class="tg-0pky">x86-64</td>
  </tr>
</table>

Both logical and arithmetic operators can be applied to a vector of
size _n_, in which case they amount to _n_ element-wise applications
of the operator on each element of the vector. Shifting an vector on the
other hand is performed at the granularity of the element on vectors,
and amounts to statically renaming variables and shifting in
zeros. For instance, if we consider a vector `x` of type `b1[4]`, `x
<< 2` is equivalent to `(x[0], x[1], x[2], x[3]) << 2`, which is
reduced at compile time to `(x[2], x[3], 0, 0)` (with the last two `0`
being of type `b1`).

Logic instructions can be applied on any non-vector type for any
slicing, as long as the architecture offers large enough
registers. Arithmetic instructions on non-vector types is only valid
for vslicing, and require some support from the underlying
architecture. In pratice, SSE, AVX, AVX2 and AVX512 offer instructions
to do 8-bit, 16-bit, 32-bit and 64-bit arithmetics. Vertical shifts of
16-bit, 32-bit and 64-bit values use CPU shift instructions (`vpsrl`
and `vpsll` on AVX2, `shr` and `shl` on general purpose x86). Shifts
in horizontal slicing are compiled using shuffle instructions
(`vpshufd`, `vpshufb`, _etc._). For instance, consider a variable `x`
of type `u16`: shifting right this variable by 2 is done using the
shuffle pattern `[-1,-1,15,14,13,12,11,10,9,8,7,6,5,4,3,2]` (`-1` in
the pattern causes a `0` to be introduced). SIMD registers older than
AVX512 only offer shuffles for up to 16 elements, while AVX512 does
also provide 32 and 64 elements shuffle, thus allowing us to compile
64-bit shifts. Shuffle instruction in horizontal mode map naturally to
SIMD shuffle instructions. And finally, Shuffle instructions in
vertical mode are compiled to shifts moving each bit in a
register. For instance, shuffling a variable `x` of type `u8` with the
pattern `[5,2,0,1,7,6,4,3]` produces the following code:

```c
((x << 5) & 128) ^
((x << 1) & 64)  ^
((x >> 2) & 32)  ^
((x >> 2) & 16)  ^
((x >> 3) & 8)   ^
((x << 1) & 4)   ^
((x >> 2) & 2)   ^
((x >> 4) & 1)
```

Since SIMD instructions do not offer 8-bit shifts, 8-bit shuffles in
vertical mode are only available on x86-64. Shuffles of 16, 32 and 64
bits can, on the other hand, be compiled for SIMD
architectures. Shuffles are expensive in vertical mode, but we chose
to support them nonetheless since some commonly used ciphers rely on
them, like AES.



<!--
<pre><code>
<b>nd</b>  ::=                                            (node declaration)
     |  node <i>id</i>(<b>tv</b><sup>+</sup>) returns (<b>tv</b><sup>+</sup>)                  (simple node)
         vars <b>tv</b><sup>+</sup> 
         let <b>eq</b><sup>+</sup> tel
     | table <i>id</i>(<b>tv</b><sup>+</sup>) returns (<b>tv</b><sup>+</sup>) { <i>n</i><sup>+</sup> }        (table)
     | perm <i>id</i>(<b>tv</b><sup>+</sup>) returns (<b>tv</b><sup>+</sup>) { <i>n</i><sup>+</sup> }         (permutation)
     | node[] <i>id</i>(<b>tv</b><sup>+</sup>) returns (<b>tv</b><sup>+</sup>) { <b>nd</b><sup>+</sup> }      (array of nodes)
               
<b>tv</b> ::= <i>id</i> : <b>typ</b>                (variable declaration)

<b>typ</b> ::=  <b>typ</b>[<i>n</i>]                (array type)
         | u&lt;<b>D</b>&gt;<i>m</i>×<i>n</i>             (<i>n</i> <i>m</i>-bit atoms with slicing direction <i>D</i>)
         | u<i>m</i>×<i>n</i>                (<i>n</i> <i>m</i>-bit atoms, direction polymorphic)
         | u&lt;<b>D</b>&gt;<i>m</i>               (1 <i>m</i>-bit atom with direction <i>D</i>)
         | b<i>n</i>                  (<i>n</i> 1-bit atoms (direction agnostic))
         | u<i>m</i>                  (1 <i>m</i>-bit atom, polymorphic direction)
         | v<i>n</i>                  (<i>n</i> atoms of polymorphic size and direction)

<b>D</b> ::= V          (vslicing)
     | H         (hslicing)
         
<b>eqs</b> ::=            (list of equations)
    <b>eq</b> | <b>eq</b> ; <b>eqs</b>

<b>eq</b> ::=             (equation)
    | forall <i>i</i> in [<b>aexpr</b>,<b>aexpr</b>] { <b>eqs</b> }       (universally quantified equation)
    | <b>lhs</b> = <b>expr</b>                               (equation)

<b>lhs</b> ::=                    (left hand-side of an equation)
   <b>var</b> | (<b>var</b><sup>+</sup>)

<b>var</b> ::=                      (variable)
    | <i>x</i>                      (variable)
    | <i>x</i>[<b>aexpr</b>]               (array index)
    | <i>x</i>[<b>aexpr</b><sup>+</sup>]      (array slice)
    | <i>x</i>[<b>aexpr</b> ... <b>aexpr</b>]     (array range)
    
<b>expr</b> ::=                       (expression)
    | <b>var</b>                      (variable)
    | <i>n</i>                        (integer)
    | (<b>expr</b><sup>+</sup>)            (tuple)
    | <b>unop</b> <b>expr</b>                (unary operation)
    | <b>expr</b> <b>binop</b> <b>expr</b>          (binary operation)
    | <b>expr</b> <b>shiftop</b> <b>aexpr</b>        (shift)
    | Shuffle(<b>var</b>, [<i>n</i><sup>+</sup>])   (shuffle)
    | <i>f</i>(<b>expr</b><sup>+</sup>)          (function call)
    | <i>f</i>&lt;<i>n</i>&gt;(<b>expr</b><sup>+</sup>)       (function call in an array of function)

</code>
</pre>

-->


<!--
### Type-checking

Despite its unusual combination of features, Usuba's type system is
rather unsurprising. First, it is applied to a first-order and
explicitly-typed language, thus requiring no type inference. Second,
vectors –while perhaps intimidating– can only take statically-known
sizes: we are far away from the realm of dependent types, merely
touching upon phantom types techniques. The combination of prenex
polymorphism and type-classes is well understood. We therefore refrain
from further expounding our type system.  As a result of these
features, our generic implementation of Rectangle type-checks as-is
when targeting any instruction set beyond SSE, meaning that it can be
sliced vertically or horizontally. 
-->

---

## References


[1] S. Duval, G. Leurent, [MDS Matrices with Lightweight Circuits](https://eprint.iacr.org/2018/260.pdf), IACR Trans. Symmetric Cryptol. 2018.

[2] K. E. Iverson, [Notation as a Tool of Thought](https://m-cacm.acm.org/magazines/1980/8/10988-notation-as-a-tool-of-thought/pdf), Commun. ACM 23, 1980.

[3]  [IEEE Standard VHDL Language Reference Manual](https://edg.uchicago.edu/~tang/VHDLref.pdf), 2000.

[4] P. Caspi _et al._, [LUSTRE: A declarative language for programming synchronous systems](https://www.cse.unsw.edu.au/~plaice/archive/JAP/P-ACM_POPL87-lustre.pdf), POPL, 1987.

[5] T. Pornin, [Constant-time mul](https://www.bearssl.org/ctmul.html), accessed 12/2019.

[6] D. Canright, [A Very Compact S-Box for AES](https://www.iacr.org/archive/ches2005/032.pdf), CHES, 2005.

[7] M. Kwan, [Reducing the Gate Count of Bitslice DES](http://eprint.iacr.org/2000/), 2000.

[8] D. A. Osvik, [Speeding up Serpent](https://www.ii.uib.no/~osvik/pub/aes3.pdf), AES Candidate Conference, 2000.

[9] M. Ullrich _et al._, [Finding optimal bitsliced implementations of 4×4-bit S-boxes](http://skew2011.mat.dtu.dk/proceedings/Finding%20Optimal%20Bitsliced%20Implementations%20of%204%20to%204-bit%20S-boxes.pdf), SKEW, 2011.

[10] F. Rocheteau, [Extension du langage LUSTRE et application à la conception de circuits : le langage LUSTRE-V4 et le système POLLUX](https://tel.archives-ouvertes.fr/tel-00342092) (Extension of the lustre language and application to hardware design: the lustre-v4 language and the pollux system), 1992.

[11] P. Wadler, S. Blott, [How to Make ad-hoc Polymorphism Less ad-hoc](https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf), POPL, 1988.
