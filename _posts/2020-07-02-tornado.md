---
layout: post
title: Tornado, Automatic Generation of Probing-Secure Masked Sliced Implementations
date: "2020-07-02 00:00:00"
description: 
lang: en
locale: en_US
author: Darius Mercadier
excerpt: 
comments: false
hidden: true
---

Given a high-level description of a cryptographic primitive, Tornado
synthesizes a masked implementation using the ISW-based multiplication
and refresh gadgets [1], and sharewise addition gadgets. The key role
of Usuba is to automate the generation of a sliced implementation,
upon which tightPROVE+ is then able to verify either the bit probing
or register probing security, or identify the necessary refreshes. By
integrating both tools, we derive a masked implementation from the
sliced one.

## Tornado's architecture

The overall architecture of Tornado is shown below:

<p align="center" style="margin-top:30px;margin-bottom:30px">
<img src="{{ site.baseurl }}/assets/images/blog/tornado-pipeline-final-small.png">
</p>

After normalization and optimization, the Usuba0 program is sent to
tightPROVE<sup>+</sup>, which adds refreshes if necessary. The output
of tightPROVE<sup>+</sup> is translated back to Usuba0, which Usubac
then masks: variables are replaced with arrays of shares, linear
operators and non-linear operators involving constants are applied
share-wise, and other non-linear operators and refreshes are left as
is to be replaced by masked gadgets during C code generation. Before
generating C code, a pass of _loop fusion_ merges share-wise
applications of linear operators when possible.


### Encoding and Decoding Usuba0 for tightPROVE<sup>+</sup>

The input language of tightPROVE+ consists of unrolled inlined
register-based circuits, whereas Usuba0 includes loops, nodes and node
calls. While Usubac can easily inline nodes and unroll loops, Tornado
targets low-end embedded devices with drastic memory constraint, on
which fully inlining and unrolled ciphers would not fit.

Usubac thus fully unrolls and inlines the Usuba0 code before
generating tightPROVE<sup>+</sup>'s input, but the refreshes inserted
by tightPROVE<sup>+</sup> are propagated back into the Usuba0 program
with loops, nodes and node calls.

To do so, when inlining and unrolling, we keep track of the origin of
each instruction: which node they come from, and which instruction in
that node. For each refresh inserted by TightPROVE<sup>+</sup>'s, we
therefore know where the refreshed variable comes from, and are
therefore able to insert the refresh directly in the right node.

<!--

```python
def refresh_prog(ua_source):
   ua_expanded  = inline_and_unroll(ua_source)
   tp_source    = usuba_to_tightprove(ua_expanded)
   tp_refreshed = call_tightprove(tp_source)
   ua_refreshed = tightprove_to_usuba(tp_refreshed, ua_expanded)
   return propagate_refreshes(ua_refreshed, ua_source)
```
-->


### Masking

To mask an Usuba0 program, Usubac replaces each variable with an array
of shares, and each operator with a masked gadget. The gadget to mask
a linear operator (`xor`) is simply a loop applying the operator on
each share, written directly in Usuba. To mask a negation, we only
negate the first share (since `~(r0 ^ r1 ^ ... ^ rk) == ~r0 ^ r1 ^
... ^ rk`), still in Usuba. To mask non-linear operators (`and` and
`or`), however, we introduce the operators `m&` and `m|` into Usuba,
which are transformed into calls to masked C gadgets when generating
the C code. In particular, for the multiplication (`and`), we use the
so-colled ISW gadget gadget introduced in [1]:


```c
static void isw_mult(uint32_t *res,
                     const uint32_t *op1,
                     const uint32_t *op2) {
    for (int i = 0; i <= MASKING_ORDER; i++)
        res[i] = 0;
     
    for (int i = 0; i <= MASKING_ORDER; i++) {
        res[i] ^= op1[i] & op2[i];
        
        for (int j = i+1; j <= MASKING_ORDER; j++) {
            uint32_t rnd = get_random();
            res[i] ^= rnd;
            res[j] ^= (rnd ^ (op1[i] & op2[j])) ^ (op1[j] & op2[i]);
        }
    }
}
```

while the `or`s are transformed into `not` and `and`, since `a | b ==
~(~a & ~b)`. Similarly, refreshes, either inserted manually by the
developper or automatically by tightPROVE<sup>+</sup>, are compiled
into calls to the ISW refresh routine when generating C code:


```c
static void isw_refresh(uint32_t *res,
                        const uint32_t *in) {
    for (int i=0; i<=MASKING_ORDER; i++)
        res[i] = in[i];

    for (int i=0; i<=MASKING_ORDER; i++) {
        for (int j=i+1; j<=MASKING_ORDER; j++) {
            uint32_t rnd = get_random();
            res[i] ^= rnd;
            res[j] ^= rnd;
        }
    }
}
```


#### Constants

Constants are not secret values and thus do not need to be
shared. Furthermore, when multiplying a constant with a secret value,
there is no need to use the ISW mutliplication gadgets: we can simply
multiply each share of the secret value with the constant. The cost of
masking a multiplication by a constant is thus linear in the number of
shares, rather than quadratic as the ISW gadget is. Our benchmarks
(see section "Evaluation" below) show that indeed, the more masked
multiplication a cipher has, the slower it is. Avoiding unnecessary
masked multiplications is thus essential.

For instance, Pyjamask's linear layer contains a matrix
multiplication, implemented by calling 4 times the following Usuba
node, which multiplies two 32-bit vectors `a` and `b`:

<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">node</span> <span class="nf">col_mult</span> <span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="n">b32</span><span class="o">,</span><span class="n">b</span><span class="o">:</span><span class="n">b32</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span><span class="n">b1</span><span class="p">)</span>
<span class="k">vars</span> <span class="n">acc</span><span class="o">:</span><span class="n">b32</span>
<span class="k">let</span>
    <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">31</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span>
<span class="k">tel</span>
</code></pre></div></div>

When this node is called in Pyjamask, `b` is always constant, and the
multiplication (`a[i] & b[i]`) therefore does not need to be
masked. Usubac uses a simple inference algorithm to track which
variables are constant and which are not, and is thus able to identify
that `b` does not need to be shared, and that the multiplication `a[i]
& b[i]` does not need to be masked.  This optimization both reduces
stack usage (since constant variables are kept as a single share
rather than an array of share) and increases performances (since
multiplying by a constant becomes linear rather than quadratic).


### Loop Fusion

Since each linear operation is replaced with a loop applying the
operation on each share, the masked code contains a lot of loops. The
overhead of those loops become quickly detrimental to
performances. Consider for instance the following Usuba0 snippet:

```lustre
x = a ^ b;
y = c ^ d;
z = x ^ y;
```

After masking, it becomes:


<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">MASKING_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">MASKING_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">MASKING_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>


In order to reduce the overhead of looping of each share for linear
operations, we aggressively perform loop fusion (also called _loop
jamming_) in Usubac, which consists in replacing multiple loops with a
single one. The above snippet is thus optimized to:


<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">MASKING_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>


Loop fusion is also able to reduce the amount of stack used by
allowing Usubac to replace temporary arrays with temporary
variables. In the example above, Usubac would thus convert `x` and `y`
into scalars rather than arrays and produce the following code:


<div class="language-lustre highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">forall</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">MASKING_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


On embedded devices (which Tornado targets), this is especially
beneficial since the amount of stack available is very limited (a few
dozen of kilobytes).

C compilers also perform loop fusion, but experimentally, they are
less aggressive than Usubac. We thus obtain better performances by
fusing loops directly in Usubac. On the 11 ciphers of the NIST
competition we implemented in Usuba and compiled with Tornado,
performing loop fusion in Usubac allows us to reduce stack usage of
our bitsliced implementations by 11kB on average whereas this saves
us, on average, 3kB of stack for our _n_-sliced implementations
(recall that our platform offers a measly 96kB of SRAM). It also
positively impacts performance, with a 16% average speedup for
bitslicing and a 21% average speedup for n-slicing.


## Evaluation

We evaluated Tornado on 11 cryptographic primitives from the second
round of the NIST lightweight cryptography competition. The choice of
cryptographic primitives was made on the basis that they were
self-identified as being amenable to masking. We stress that we do not
focus on the full authenticated encryption, message authentication, or
hash protocols but on the underlying primitives, mostly block ciphers
and permutations.


Table 1 provides an overview of these primitives. Whenever possible,
we generate both a bitsliced and an n-sliced implementation for each
primitive, which allows us to exercise the bit-probing and the
register-probing models of tightPROVE+. However, 4 primitives do not
admit a straightforward n-sliced implementation. The Subterranean
permutation involves a significant amount of bit-twiddling across its
257-bit state, which makes it a resolutely bitsliced primitive (as
confirmed by its reference implementation). Photon, Skinny, Spongent
rely on lookup tables that would be too expansive to emulate in
n-sliced mode. In bitslicing, these tables are simply implemented by
their Boolean circuit, either provided by the authors (Photon, Skinny)
or generated through SAT [34] with the objective of minimizing
multiplicative complexity (Spongent, with 4 ANDs and 28 XORs). Spook
and Elephant respectively rely on the Clyde and Spongent primitives,
which we therefore include in our evaluation.



<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;vertical-align:middle}
.tg .tg-xwyw{border-color:#000000;text-align:center;vertical-align:middle}
.tg .tg-wruy{border-color:#000000;color:#32cb00;text-align:center;vertical-align:middle}
.tg .tg-73t7{border-color:#000000;color:#cb0000;text-align:center;vertical-align:middle}
.tg .tg-y0n7{background-color:#efefef;text-align:center;vertical-align:middle}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-uzvj" rowspan="2">submissions</th>
    <th class="tg-uzvj" rowspan="2">primitive</th>
    <th class="tg-uzvj" rowspan="2">state size<br>(bits)</th>
    <th class="tg-uzvj" colspan="2">multiplications</th>
    <th class="tg-uzvj" colspan="2">multiplications/bits</th>
    <th class="tg-uzvj" rowspan="2">n-sliceable</th>
    <th class="tg-uzvj" rowspan="2">slice size</th>
  </tr>
  <tr>
    <td class="tg-uzvj">n-slice</td>
    <td class="tg-uzvj">bitslice</td>
    <td class="tg-uzvj">n-slice</td>
    <td class="tg-uzvj">bitslice</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-y0n7" colspan="9">block ciphers</td>
  </tr>
  <tr>
    <td class="tg-9wq8">GIFT-COFB,<br>HYENA,<br>SUNDAE-GIFT</td>
    <td class="tg-9wq8">GIFT-128</td>
    <td class="tg-9wq8">128</td>
    <td class="tg-9wq8">160</td>
    <td class="tg-9wq8">5120</td>
    <td class="tg-xwyw">1.25</td>
    <td class="tg-xwyw">40</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">32</td>
  </tr>
  <tr>
    <td class="tg-c3ow">Pyjamask</td>
    <td class="tg-9wq8">Pyjamask-128</td>
    <td class="tg-9wq8">128</td>
    <td class="tg-9wq8">56</td>
    <td class="tg-9wq8">1792</td>
    <td class="tg-xwyw">0.44</td>
    <td class="tg-xwyw">14</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">32</td>
  </tr>
  <tr>
    <td class="tg-9wq8">SKINNY,<br>ROMULUS</td>
    <td class="tg-9wq8">SKINNY-128-256</td>
    <td class="tg-9wq8">128</td>
    <td class="tg-9wq8">-</td>
    <td class="tg-9wq8">6144</td>
    <td class="tg-xwyw">-</td>
    <td class="tg-xwyw">48</td>
    <td class="tg-73t7">✖</td>
    <td class="tg-xwyw">-</td>
  </tr>
  <tr>
    <td class="tg-9wq8">Spook</td>
    <td class="tg-9wq8">Clyde-128</td>
    <td class="tg-9wq8">128</td>
    <td class="tg-9wq8">48</td>
    <td class="tg-9wq8">1536</td>
    <td class="tg-xwyw">0.37</td>
    <td class="tg-xwyw">12</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">32</td>
  </tr>
  <tr>
    <td class="tg-y0n7" colspan="9">permutations</td>
  </tr>
  <tr>
    <td class="tg-9wq8">ACE</td>
    <td class="tg-9wq8">ACE</td>
    <td class="tg-9wq8">320</td>
    <td class="tg-9wq8">384</td>
    <td class="tg-9wq8">12288</td>
    <td class="tg-xwyw">1.2</td>
    <td class="tg-xwyw">38</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">32</td>
  </tr>
  <tr>
    <td class="tg-9wq8">ASCON</td>
    <td class="tg-9wq8"><i>p<sup>12</sup></i></td>
    <td class="tg-9wq8">320</td>
    <td class="tg-9wq8">60</td>
    <td class="tg-9wq8">3840</td>
    <td class="tg-xwyw">0.19</td>
    <td class="tg-xwyw">12</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">64</td>
  </tr>
  <tr>
    <td class="tg-9wq8">Elephant</td>
    <td class="tg-9wq8">SPONGENT-π[160]</td>
    <td class="tg-9wq8">160</td>
    <td class="tg-9wq8">-</td>
    <td class="tg-9wq8">12800</td>
    <td class="tg-xwyw">-</td>
    <td class="tg-xwyw">80</td>
    <td class="tg-73t7">✖</td>
    <td class="tg-xwyw">-</td>
  </tr>
  <tr>
    <td class="tg-9wq8">Gimli</td>
    <td class="tg-9wq8">Gimli-36</td>
    <td class="tg-9wq8">384</td>
    <td class="tg-9wq8">288</td>
    <td class="tg-9wq8">9216</td>
    <td class="tg-xwyw">0.75</td>
    <td class="tg-xwyw">24</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">32</td>
  </tr>
  <tr>
    <td class="tg-9wq8">ORANGE,<br>PHOTON-BEETLE</td>
    <td class="tg-9wq8">PHOTON-256</td>
    <td class="tg-9wq8">256</td>
    <td class="tg-9wq8">-</td>
    <td class="tg-9wq8">3072</td>
    <td class="tg-xwyw">-</td>
    <td class="tg-xwyw">12</td>
    <td class="tg-73t7">✖</td>
    <td class="tg-xwyw">-</td>
  </tr>
  <tr>
    <td class="tg-9wq8">Xoodyak</td>
    <td class="tg-9wq8">Xoodoo</td>
    <td class="tg-9wq8">384</td>
    <td class="tg-9wq8">144</td>
    <td class="tg-9wq8">4608</td>
    <td class="tg-xwyw">0.37</td>
    <td class="tg-xwyw">12</td>
    <td class="tg-wruy">✔</td>
    <td class="tg-xwyw">32</td>
  </tr>
  <tr>
    <td class="tg-y0n7" colspan="9">others</td>
  </tr>
  <tr>
    <td class="tg-c3ow">Subterranean</td>
    <td class="tg-9wq8">blank(8)</td>
    <td class="tg-9wq8">257</td>
    <td class="tg-9wq8">-</td>
    <td class="tg-9wq8">2056</td>
    <td class="tg-xwyw">-</td>
    <td class="tg-xwyw">8</td>
    <td class="tg-73t7">✖</td>
    <td class="tg-xwyw">-</td>
  </tr>
</tbody>
</table>



Note that the n-sliced implementations, when they exist, are either 32-sliced or 64-sliced.
This means in particular that, unlike bitslicing that processes multiple blocks in parallel, these
implementations process a single block at once on our 32-bit Cortex M4.


In Subsection 5.1, we present the results of tightPROVE+ on the considered primitives using
the refresh placement strategy explained in Subsection 4.1. Finally, we benchmark our unmasked
implementations against reference implementations in Subsection 5.2, and compare their masked
versions in Subsection 5.3.

We now turn to the evaluation of the masked implementations produced
by Tornado using the Usuba implementations presented in the previous
section. Our benchmarks are run on a Nucleo STM32F401RE offering an
Arm Cortex-M4 with 512 Kbytes of Flash memory and 96 Kbytes of
SRAM. We used the GNU C compiler arm-none-eabi-gcc version 9.2.0 at
optimization level -O3.  We considered two modes regarding the Random
Number Generator (RNG):


 - Pooling mode: The RNG generates random numbers at a rate of 32 bits
   every 64 clock cycles.  Fetching a random number can thus take up
   to 65 clock cycles.

 - Fast mode: The RNG only takes a few clock cycles to generate a
   32-bit random word. The RNG routine thus can simply read a register
   containing this 32-bit random word without checking for its
   availability.


Those two modes were chosen because they are the ones used in the
submission of Pyjamask, which is the only submission detailing the
question of how to get random numbers for a masked implementation.

Of these 11 NIST submissions, only Pyjamask provides a masked
implementation. Our implementation is consistently (at every order,
and with both the pooling and fast RNGs) 1.8 times 21 slower than
their masked implementation. The reason is twofold. First, their
reference implementation has been heavily optimized to take advantage
of the barrel shifter on the Cortex M4, which we do not
exploit. Second, our implementation uses the generic ISW
multiplication (Figure 7) whereas the reference implementation employs
a specialized, hand-tuned implementation in assembly

---
## References

[1] Y. Ishai _et al._, [Private Circuits: Securing Hardware against Probing Attacks](https://people.eecs.berkeley.edu/~daw/papers/privcirc-crypto03.pdf), CRYPTO, 2003.
