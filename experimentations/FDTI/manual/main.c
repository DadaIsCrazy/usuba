#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>

/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba. */

#define assert(e) if (!(e)) fprintf(stderr,"Assert failed line %d.\n",__LINE__)
#define assertFatal(e) if (!(e)) {                          \
    fprintf(stderr,"Assert failed line %d.\n",__LINE__);    \
    exit(EXIT_FAILURE);                                     \
  }


#define DATATYPE unsigned int
#define _AND(a,b)  (((a) & (b))&1)
#define _OR(a,b)   (((a) | (b))&1)
#define _XOR(a,b)  (((a) ^ (b))&1)
#define _NOT(a)    ((~(a))&1)


/* ****************************************************** */
/*                   Fault detection stuffs               */
unsigned int err = 1;
unsigned int fault = 0;

#define proba 100
//#define INJECT_FAULT(v) v
#define INJECT_FAULT(v) ({                              \
      int c = (rand() % proba == 0) && (fault == 0);    \
      if (c == 1) { fault = 1;}                         \
      c ? ~v&1 : v;                                     \
    })
#define AND_FAULT(a,b) INJECT_FAULT(_AND(a,b))
#define OR_FAULT(a,b)  INJECT_FAULT(_OR(a,b))
#define XOR_FAULT(a,b) INJECT_FAULT(_XOR(a,b))
#define NOT_FAULT(a)   INJECT_FAULT(_NOT(a))
/* ****************************************************** */



/* ****************************************************** */
/*                        Masking stuffs                  */
unsigned int A = 0;
unsigned int B = 0;
unsigned int i = 0;
unsigned long count[2][2][1000];

#define COUNT(r) ({ DATATYPE res = r; count[A][B][i++] += res & 1; res; })
#define AND_COUNT(a,b) COUNT(_AND(a,b))
#define OR_COUNT(a,b)  COUNT(_OR(a,b))
#define XOR_COUNT(a,b) COUNT(_XOR(a,b))
#define NOT_COUNT(a)   COUNT(_NOT(a))
/* ****************************************************** */


#ifdef CORRECTNESS
#define AND _AND
#define OR  _OR
#define XOR _XOR
#define NOT _NOT
#else
#ifdef MASK
#define AND AND_COUNT
#define OR  OR_COUNT
#define XOR XOR_COUNT
#define NOT NOT_COUNT
#else
#ifdef FAULT
#define AND AND_FAULT
#define OR  OR_FAULT
#define XOR XOR_FAULT
#define NOT NOT_FAULT
#endif
#endif
#endif


/* ****************************************************** */
/*                    The various adders                  */

/* auxiliary functions */
void adder__ (/*inputs*/ DATATYPE a__,DATATYPE b__, /*outputs*/ DATATYPE* s__,DATATYPE* c__) {
  
  // Variables declaration


  // Instructions (body)
  *s__ = XOR(a__,b__);
  *c__ = AND(a__,b__);

}

void normal2TI__ (/*inputs*/ DATATYPE a__,DATATYPE r__0__,DATATYPE r__1__, /*outputs*/ DATATYPE* a____0__,DATATYPE* a____1__,DATATYPE* a____2__) {
  
  // Variables declaration
  DATATYPE _tmp1_;
  DATATYPE _tmp2_;


  // Instructions (body)
  _tmp1_ = XOR(a__,r__0__);
  _tmp2_ = XOR(_tmp1_,r__1__);
  *a____0__ = r__0__;
  *a____1__ = r__1__;
  *a____2__ = _tmp2_;

}

void TI2normal__ (/*inputs*/ DATATYPE a____0__,DATATYPE a____1__,DATATYPE a____2__, /*outputs*/ DATATYPE* a__) {
  
  // Variables declaration
  DATATYPE _tmp3_;


  // Instructions (body)
  _tmp3_ = XOR(a____0__,a____1__);
  *a__ = XOR(_tmp3_,a____2__);

}

void normal2FD__ (/*inputs*/ DATATYPE a__, /*outputs*/ DATATYPE* a____0__,DATATYPE* a____1__) {
  
  // Variables declaration
  DATATYPE _tmp4_;


  // Instructions (body)
  _tmp4_ = NOT(a__);
  *a____0__ = a__;
  *a____1__ = _tmp4_;

}

void FD2normal__ (/*inputs*/ DATATYPE a____0__,DATATYPE a____1__, /*outputs*/ DATATYPE* a__,DATATYPE* c__) {
  
  // Variables declaration


  // Instructions (body)
  *a__ = a____0__;
  *c__ = AND(a____0__,a____1__);

}

/* auxiliary functions */
void andTI__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__) {
  
  // Variables declaration
  DATATYPE c1__0__;
  DATATYPE c1__1__;
  DATATYPE c1__2__;
  DATATYPE c2__0__;
  DATATYPE c2__1__;
  DATATYPE c2__2__;
  DATATYPE c3__0__;
  DATATYPE c3__1__;
  DATATYPE c3__2__;
  DATATYPE d1__0__;
  DATATYPE d1__1__;
  DATATYPE d1__2__;
  DATATYPE d2__0__;
  DATATYPE d2__1__;
  DATATYPE d2__2__;
  DATATYPE d3__0__;
  DATATYPE d3__1__;
  DATATYPE d3__2__;
  DATATYPE d4__0__;
  DATATYPE d4__1__;
  DATATYPE d4__2__;


  // Instructions (body)
  c1__0__ = AND(a__0__,b__0__);
  c1__1__ = AND(a__1__,b__1__);
  c1__2__ = AND(a__2__,b__2__);
  c2__0__ = AND(a__0__,b__1__);
  c2__1__ = AND(a__1__,b__2__);
  c2__2__ = AND(a__2__,b__0__);
  c3__0__ = AND(a__1__,b__0__);
  c3__1__ = AND(a__2__,b__1__);
  c3__2__ = AND(a__0__,b__2__);
  d1__0__ = XOR(c1__0__,r__0__);
  d1__1__ = XOR(c1__1__,r__1__);
  d1__2__ = XOR(c1__2__,r__2__);
  d2__0__ = XOR(d1__0__,c2__0__);
  d2__1__ = XOR(d1__1__,c2__1__);
  d2__2__ = XOR(d1__2__,c2__2__);
  d3__0__ = XOR(d2__0__,c3__0__);
  d3__1__ = XOR(d2__1__,c3__1__);
  d3__2__ = XOR(d2__2__,c3__2__);
  d4__0__ = XOR(d3__0__,r__1__);
  d4__1__ = XOR(d3__1__,r__2__);
  d4__2__ = XOR(d3__2__,r__0__);
  *x__0__ = d4__0__;
  *x__1__ = d4__1__;
  *x__2__ = d4__2__;

}

void notTI__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__, /*outputs*/ DATATYPE* a____0__,DATATYPE* a____1__,DATATYPE* a____2__) {
  
  // Variables declaration
  DATATYPE _tmp7_;


  // Instructions (body)
  _tmp7_ = NOT(a__0__);
  *a____0__ = _tmp7_;
  *a____1__ = NOT(a__1__);
  *a____2__ = NOT(a__2__);

}

void orTI__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__) {
  
  // Variables declaration
  DATATYPE _tmp8_1;
  DATATYPE _tmp8_2;
  DATATYPE _tmp8_3;
  DATATYPE _tmp9_1;
  DATATYPE _tmp9_2;
  DATATYPE _tmp9_3;


  // Instructions (body)
  notTI__(a__0__,a__1__,a__2__,&_tmp8_1,&_tmp8_2,&_tmp8_3);
  notTI__(b__0__,b__1__,b__2__,&_tmp9_1,&_tmp9_2,&_tmp9_3);
  andTI__(_tmp8_1,_tmp8_2,_tmp8_3,_tmp9_1,_tmp9_2,_tmp9_3,r__0__,r__1__,r__2__,&_tmp8_1,&_tmp8_2,&_tmp8_3);
  notTI__(_tmp8_1,_tmp8_2,_tmp8_3,&*x__0__,&*x__1__,&*x__2__);

}


void andFDTI__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE a__3__,DATATYPE a__4__,DATATYPE a__5__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE b__3__,DATATYPE b__4__,DATATYPE b__5__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__,DATATYPE r__3__,DATATYPE r__4__,DATATYPE r__5__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__,DATATYPE* x__3__,DATATYPE* x__4__,DATATYPE* x__5__,DATATYPE* c__0__,DATATYPE* c__1__,DATATYPE* c__2__) {
  
  // Variables declaration


  // Instructions (body)
  andTI__(a__0__,a__2__,a__4__,b__0__,b__2__,b__4__,r__0__,r__2__,r__4__,&*x__0__,&*x__2__,&*x__4__);
  orTI__(a__1__,a__3__,a__5__,b__1__,b__3__,b__5__,r__1__,r__3__,r__5__,&*x__1__,&*x__3__,&*x__5__);
  *c__0__ = XOR(*x__0__,*x__1__);
  *c__1__ = XOR(*x__2__,*x__3__);
  *c__2__ = XOR(*x__4__,*x__5__);

  err &= *c__0__ & *c__1__ & *c__2__;  
}

void xorFDTI__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE a__3__,DATATYPE a__4__,DATATYPE a__5__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE b__3__,DATATYPE b__4__,DATATYPE b__5__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__,DATATYPE* x__3__,DATATYPE* x__4__,DATATYPE* x__5__,DATATYPE* c__0__,DATATYPE* c__1__,DATATYPE* c__2__) {
  
  // Variables declaration


  // Instructions (body)
  *x__0__ = XOR(a__0__,b__0__);
  *x__1__ = NOT(XOR(a__1__,b__1__));
  *x__2__ = XOR(a__2__,b__2__);
  *x__3__ = NOT(XOR(a__3__,b__3__));
  *x__4__ = XOR(a__4__,b__4__);
  *x__5__ = NOT(XOR(a__5__,b__5__));
  *c__0__ = XOR(*x__0__,*x__1__);
  *c__1__ = XOR(*x__2__,*x__3__);
  *c__2__ = XOR(*x__4__,*x__5__);

  err &= *c__0__ & *c__1__ & *c__2__;
  
}

void adderFDTI__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE a__3__,DATATYPE a__4__,DATATYPE a__5__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE b__3__,DATATYPE b__4__,DATATYPE b__5__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__,DATATYPE r__3__,DATATYPE r__4__,DATATYPE r__5__, /*outputs*/ DATATYPE* s__0__,DATATYPE* s__1__,DATATYPE* s__2__,DATATYPE* s__3__,DATATYPE* s__4__,DATATYPE* s__5__,DATATYPE* c__0__,DATATYPE* c__1__,DATATYPE* c__2__,DATATYPE* c__3__,DATATYPE* c__4__,DATATYPE* c__5__) {
  
  // Variables declaration
  DATATYPE c1__0__;
  DATATYPE c1__1__;
  DATATYPE c1__2__;
  DATATYPE c2__0__;
  DATATYPE c2__1__;
  DATATYPE c2__2__;


  // Instructions (body)
  xorFDTI__(a__0__,a__1__,a__2__,a__3__,a__4__,a__5__,b__0__,b__1__,b__2__,b__3__,b__4__,b__5__,&*s__0__,&*s__1__,&*s__2__,&*s__3__,&*s__4__,&*s__5__,&c1__0__,&c1__1__,&c1__2__);
  andFDTI__(a__0__,a__1__,a__2__,a__3__,a__4__,a__5__,b__0__,b__1__,b__2__,b__3__,b__4__,b__5__,r__0__,r__1__,r__2__,r__3__,r__4__,r__5__,&*c__0__,&*c__1__,&*c__2__,&*c__3__,&*c__4__,&*c__5__,&c2__0__,&c2__1__,&c2__2__);

}

void andTI____ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__) {
  
  // Variables declaration
  DATATYPE c1__0__;
  DATATYPE c1__1__;
  DATATYPE c1__2__;
  DATATYPE c2__0__;
  DATATYPE c2__1__;
  DATATYPE c2__2__;
  DATATYPE c3__0__;
  DATATYPE c3__1__;
  DATATYPE c3__2__;
  DATATYPE d1__0__;
  DATATYPE d1__1__;
  DATATYPE d1__2__;
  DATATYPE d2__0__;
  DATATYPE d2__1__;
  DATATYPE d2__2__;
  DATATYPE d3__0__;
  DATATYPE d3__1__;
  DATATYPE d3__2__;
  DATATYPE d4__0__;
  DATATYPE d4__1__;
  DATATYPE d4__2__;


  // Instructions (body)
  c1__0__ = OR(a__0__,b__0__);
  c1__1__ = OR(a__1__,b__1__);
  c1__2__ = OR(a__2__,b__2__);
  c2__0__ = OR(a__0__,b__1__);
  c2__1__ = OR(a__1__,b__2__);
  c2__2__ = OR(a__2__,b__0__);
  c3__0__ = OR(a__1__,b__0__);
  c3__1__ = OR(a__2__,b__1__);
  c3__2__ = OR(a__0__,b__2__);
  d1__0__ = XOR(c1__0__,r__0__);
  d1__1__ = XOR(c1__1__,r__1__);
  d1__2__ = XOR(c1__2__,r__2__);
  d2__0__ = XOR(d1__0__,c2__0__);
  d2__1__ = XOR(d1__1__,c2__1__);
  d2__2__ = XOR(d1__2__,c2__2__);
  d3__0__ = XOR(d2__0__,c3__0__);
  d3__1__ = XOR(d2__1__,c3__1__);
  d3__2__ = XOR(d2__2__,c3__2__);
  d4__0__ = XOR(d3__0__,r__1__);
  d4__1__ = XOR(d3__1__,r__2__);
  d4__2__ = XOR(d3__2__,r__0__);
  *x__0__ = d4__0__;
  *x__1__ = d4__1__;
  *x__2__ = d4__2__;

}

void andTIFD__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE a__3__,DATATYPE a__4__,DATATYPE a__5__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE b__3__,DATATYPE b__4__,DATATYPE b__5__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__,DATATYPE r__3__,DATATYPE r__4__,DATATYPE r__5__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__,DATATYPE* x__3__,DATATYPE* x__4__,DATATYPE* x__5__,DATATYPE* c__0__,DATATYPE* c__1__,DATATYPE* c__2__) {
  
  // Variables declaration

  // Instructions (body)
  andTI__(a__0__,a__1__,a__2__,b__0__,b__1__,b__2__,r__0__,r__1__,r__2__,&*x__0__,&*x__1__,&*x__2__);
  andTI____(a__3__,a__4__,a__5__,b__3__,b__4__,b__5__,r__3__,r__4__,r__5__,&*x__3__,&*x__4__,&*x__5__);
  *c__0__ = XOR(*x__0__,*x__3__);
  *c__1__ = XOR(*x__1__,*x__4__);
  *c__2__ = XOR(*x__2__,*x__5__);

  err &= *c__0__ & *c__1__ & *c__2__;
}

void xorTIFD__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE a__3__,DATATYPE a__4__,DATATYPE a__5__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE b__3__,DATATYPE b__4__,DATATYPE b__5__, /*outputs*/ DATATYPE* x__0__,DATATYPE* x__1__,DATATYPE* x__2__,DATATYPE* x__3__,DATATYPE* x__4__,DATATYPE* x__5__,DATATYPE* c__0__,DATATYPE* c__1__,DATATYPE* c__2__) {
  
  // Variables declaration


  // Instructions (body)
  *x__0__ = XOR(a__0__,b__0__);
  *x__1__ = XOR(a__1__,b__1__);
  *x__2__ = XOR(a__2__,b__2__);
  *x__3__ = NOT(XOR(a__3__,b__3__));
  *x__4__ = NOT(XOR(a__4__,b__4__));
  *x__5__ = NOT(XOR(a__5__,b__5__));
  *c__0__ = XOR(*x__0__,*x__3__);
  *c__1__ = XOR(*x__1__,*x__4__);
  *c__2__ = XOR(*x__2__,*x__5__);

  err &= *c__0__ & *c__1__ & *c__2__;
}

void adderTIFD__ (/*inputs*/ DATATYPE a__0__,DATATYPE a__1__,DATATYPE a__2__,DATATYPE a__3__,DATATYPE a__4__,DATATYPE a__5__,DATATYPE b__0__,DATATYPE b__1__,DATATYPE b__2__,DATATYPE b__3__,DATATYPE b__4__,DATATYPE b__5__,DATATYPE r__0__,DATATYPE r__1__,DATATYPE r__2__,DATATYPE r__3__,DATATYPE r__4__,DATATYPE r__5__, /*outputs*/ DATATYPE* s__0__,DATATYPE* s__1__,DATATYPE* s__2__,DATATYPE* s__3__,DATATYPE* s__4__,DATATYPE* s__5__,DATATYPE* c__0__,DATATYPE* c__1__,DATATYPE* c__2__,DATATYPE* c__3__,DATATYPE* c__4__,DATATYPE* c__5__) {
  
  // Variables declaration
  DATATYPE c1__0__;
  DATATYPE c1__1__;
  DATATYPE c1__2__;
  DATATYPE c2__0__;
  DATATYPE c2__1__;
  DATATYPE c2__2__;


  // Instructions (body)
  xorTIFD__(a__0__,a__1__,a__2__,a__3__,a__4__,a__5__,b__0__,b__1__,b__2__,b__3__,b__4__,b__5__,&*s__0__,&*s__1__,&*s__2__,&*s__3__,&*s__4__,&*s__5__,&c1__0__,&c1__1__,&c1__2__);
  andTIFD__(a__0__,a__1__,a__2__,a__3__,a__4__,a__5__,b__0__,b__1__,b__2__,b__3__,b__4__,b__5__,r__0__,r__1__,r__2__,r__3__,r__4__,r__5__,&*c__0__,&*c__1__,&*c__2__,&*c__3__,&*c__4__,&*c__5__,&c2__0__,&c2__1__,&c2__2__);

}



#define FOR(i) for (int i = 0; i <= 1; i++)
#define LIST(a) a##0, a##1, a##2, a##3, a##4, a##5
#define LISTalt(a) a##0, a##3, a##1, a##4, a##2, a##5
#define LISTaddr(a) &a##0, &a##1, &a##2, &a##3, &a##4, &a##5
#define LISTaltaddr(a) &a##0, &a##3, &a##1, &a##4, &a##2, &a##5

void checkCorrectness() {

  FOR(a0) FOR(a1) FOR(a2)
    FOR(b0) FOR(b1) FOR(b2)
    FOR(r0) FOR(r1) FOR(r2) {
    int a3 = ~a0, a4 = ~a1, a5 = ~a2;
    int b3 = ~b0, b4 = ~b1, b5 = ~b2;
    int r3 = ~r0, r4 = ~r1, r5 = ~r2;
    
    DATATYPE LIST(x0_), LIST(x1_), LIST(c0_), LIST(c1_);

    DATATYPE A = a0 ^ a1 ^ a2;
    DATATYPE B = b0 ^ b1 ^ b2;

    /* Reference adder */
    DATATYPE X, C;
    adder__(A,B,&X,&C);
    assertFatal((X == (A ^ B)) && (C == (A & B)));

    /* Check TI / FD adders */
    adderTIFD__(LIST(a),LIST(b),LIST(r),LISTaddr(x0_),LISTaddr(c0_));
    adderFDTI__(LISTalt(a),LISTalt(b),LISTalt(r),LISTaltaddr(x1_),LISTaltaddr(c1_));

    /* Check correct result */
    assertFatal(((x0_0^x0_1^x0_2) == (A^B)) && ((c0_0^c0_1^c0_2) == (A&B)));
    assertFatal(((x1_0^x1_1^x1_2) == (A^B)) && ((c1_0^c1_1^c1_2) == (A&B)));

    /* Check correct complementary result */
    assertFatal((x0_0 ^ x0_1 ^ x0_2) != (x0_3 ^ x0_4 ^ x0_5));
    assertFatal((x1_0 ^ x1_1 ^ x1_2) != (x1_3 ^ x1_4 ^ x1_5));
    assertFatal((c0_0 ^ c0_1 ^ c0_2) != (c0_3 ^ c0_4 ^ c0_5));
    assertFatal((c1_0 ^ c1_1 ^ c1_2) != (c1_3 ^ c1_4 ^ c1_5));
    assertFatal((x0_0 != x0_3) && (x0_1 != x0_4) && (x0_2 != x0_5));
    assertFatal((x1_0 != x1_3) && (x1_1 != x1_4) && (x1_2 != x1_5));
    assertFatal((c0_0 != c0_3) && (c0_1 != c0_4) && (c0_2 != c0_5));
    assertFatal((c1_0 != c1_3) && (c1_1 != c1_4) && (c1_2 != c1_5));
    
    /* Check equivalence between FDTI and TIFD */
    assertFatal((x0_0 ^ x0_1 ^ x0_2) == (x1_0 ^ x1_1 ^ x1_2));
    assertFatal((x0_3 ^ x0_4 ^ x0_5) == (x1_3 ^ x1_4 ^ x1_5));
    assertFatal((c0_0 ^ c0_1 ^ c0_2) == (c1_0 ^ c1_1 ^ c1_2));
    assertFatal((c0_3 ^ c0_4 ^ c0_5) == (c1_3 ^ c1_4 ^ c1_5));
    
  }

  printf("Program correct.\n");
}

void checkMask() {

  unsigned long countSum[2][2][64];
  unsigned long countCarry[2][2][64];
  
  for (int j = 0; j < 1000; j++)
    count[0][0][j] = count[1][0][j] = count[0][1][j] = count[1][1][j] = 0; /* global */
  for (int j = 0; j < 64; j++)
    countSum[0][0][j] = countSum[1][0][j] = countSum[0][1][j] = countSum[1][1][j] = 0; /* global */
  for (int j = 0; j < 64; j++)
    countCarry[0][0][j] = countCarry[1][0][j] = countCarry[0][1][j] = countCarry[1][1][j] = 0; /* global */
  
  FOR(a0) FOR(a1) FOR(a2)
    FOR(b0) FOR(b1) FOR(b2)
    FOR(r0) FOR(r1) FOR(r2)  {
    int a3 = ~a0, a4 = ~a1, a5 = ~a2;
    int b3 = ~b0, b4 = ~b1, b5 = ~b2;
    int r3 = ~r0, r4 = ~r1, r5 = ~r2;

    /* globals */
    A = a0 ^ a1 ^ a2;
    B = b0 ^ b1 ^ b2;
    i = 0;
    
    DATATYPE LIST(x), LIST(c);
    if (0)
      adderTIFD__(LIST(a),LIST(b),LIST(r),LISTaddr(x),LISTaddr(c));
    else
      adderFDTI__(LISTalt(a),LISTalt(b),LISTalt(r),LISTaltaddr(x),LISTaltaddr(c));

    unsigned int layoutSum = (x0&1) << 5 | (x1&1) << 4 | (x2&1) << 3 |
      (x3&1) << 2 | (x4&1) << 1 | (x5&1);
    unsigned int layoutCarry = (c0&1) << 5 | (c1&1) << 4 | (c2&1) << 3 |
      (c3&1) << 2 | (c4&1) << 1 | (c5&1);
    
    countSum[A][B][layoutSum]++;
    countCarry[A][B][layoutCarry]++;
    
  }
  for (unsigned int j = 0; j < i; j++) {
    assertFatal((count[0][0][j]+count[0][1][j] == count[0][0][j]+count[1][0][j]) &&
                (count[0][0][j]+count[0][1][j] == count[1][0][j]+count[1][1][j]) &&
                (count[0][0][j]+count[0][1][j] == count[0][1][j]+count[1][1][j]));
  }

  // Checking that the distribution of the results are equiprobable
  for (unsigned int j = 1; j < 64; j++) {
    int i1 = (j>>5)&1, i2=(j>>4)&1, i3=(j>>3)&1, i4=(j>>2)&1,i5=(j>>1)&1,i6=j&1;
    if (i1 == i4 || i2 == i5 || i3 == i6) continue;
    for (int A = 0; A <= 1; A++) {
      for (int B = 0; B <= 1; B++) {
        if ((A ^ B) == 0 && (i1 ^ i2 ^ i3) == 0)
          assertFatal( countSum[A][B][j] == countSum[A][B][0b000111] );
        if ((A ^ B) == 1 && (i1 ^ i2 ^ i3) == 1)
          assertFatal( countSum[A][B][j] == countSum[A][B][0b001110] );
        if ((A & B) == 0 && (i1 ^ i2 ^ i3) == 0)
          assertFatal( countCarry[A][B][j] == countCarry[A][B][0b000111] );
        if ((A & B) == 1 && (i1 ^ i2 ^ i3) == 1)
          assertFatal( countCarry[A][B][j] == countCarry[A][B][0b001110] );
        
      }
    }
  }
  
  printf("Masking correct.\n");
}

void checkFault() {
  int cpt_fault = 0, cpt_err = 0;
  
  FOR(a0) FOR(a1) FOR(a2)
    FOR(b0) FOR(b1) FOR(b2) 
    FOR(r0) FOR(r1) FOR(r2) {
    int a3 = ~a0, a4 = ~a1, a5 = ~a2;
    int b3 = ~b0, b4 = ~b1, b5 = ~b2;
    int r3 = ~r0, r4 = ~r1, r5 = ~r2;
    A = a0 ^ a1 ^ a2;
    B = b0 ^ b1 ^ b2;

     /* globals */
    fault = 0;
    err = 1;
    
    DATATYPE LIST(x), LIST(c);
    if (0)
      adderTIFD__(LIST(a),LIST(b),LIST(r),LISTaddr(x),LISTaddr(c));
    else
      adderFDTI__(LISTalt(a),LISTalt(b),LISTalt(r),LISTaltaddr(x),LISTaltaddr(c));
    if (fault && err && ((x0 ^ x1 ^ x2 == x3 ^ x4 ^ x5) ||
                         (c0 ^ c1 ^ c2 == c3 ^ c4 ^ c5))) {
      printf("Error not detected (1)\n");
      exit(EXIT_FAILURE);
    }
    if (!fault && !err) {
      printf("Wrong error detected\n");
      exit(EXIT_FAILURE);
    }
    cpt_fault += (fault&1);
    cpt_err += (err != 1);
  }
  printf("Fault detection correct (Injected: %d, Detected: %d)\n",cpt_fault,cpt_err);
}

int main() {
  
  srand(time(NULL));

  #ifdef CORRECTNESS
  checkCorrectness();
  #else
  #ifdef MASK
  checkMask();
  #else
  #ifdef FAULT
  checkFault();
  #endif
  #endif
  #endif
  
  return 0;
}
