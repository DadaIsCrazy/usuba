/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "adder.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 64
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */
void full_adder__B1 (/*inputs*/ DATATYPE a__,DATATYPE b__,DATATYPE cin__, /*outputs*/ DATATYPE* s__,DATATYPE* cout__) {

  // Variables declaration
  DATATYPE _tmp1_;
  DATATYPE _tmp2_;
  DATATYPE _tmp4_;

  // Instructions (body)
  _tmp1_ = XOR(a__,b__);
  _tmp2_ = AND(a__,b__);
  *s__ = XOR(_tmp1_,cin__);
  _tmp4_ = AND(cin__,_tmp1_);
  *cout__ = XOR(_tmp2_,_tmp4_);

}

void add_8__ (/*inputs*/ DATATYPE a__[8],DATATYPE b__[8], /*outputs*/ DATATYPE s__[8]) {

  // Variables declaration
  DATATYPE c__;

  // Instructions (body)
  c__ = SET_ALL_ZERO();
  full_adder__B1(a__[0],b__[0],c__,&s__[0],&c__);
  full_adder__B1(a__[1],b__[1],c__,&s__[1],&c__);
  full_adder__B1(a__[2],b__[2],c__,&s__[2],&c__);
  full_adder__B1(a__[3],b__[3],c__,&s__[3],&c__);
  full_adder__B1(a__[4],b__[4],c__,&s__[4],&c__);
  full_adder__B1(a__[5],b__[5],c__,&s__[5],&c__);
  full_adder__B1(a__[6],b__[6],c__,&s__[6],&c__);
  full_adder__B1(a__[7],b__[7],c__,&s__[7],&c__);

}

void add_16__ (/*inputs*/ DATATYPE a__[16],DATATYPE b__[16], /*outputs*/ DATATYPE s__[16]) {

  // Variables declaration
  DATATYPE c__;

  // Instructions (body)
  c__ = SET_ALL_ZERO();
  full_adder__B1(a__[0],b__[0],c__,&s__[0],&c__);
  full_adder__B1(a__[1],b__[1],c__,&s__[1],&c__);
  full_adder__B1(a__[2],b__[2],c__,&s__[2],&c__);
  full_adder__B1(a__[3],b__[3],c__,&s__[3],&c__);
  full_adder__B1(a__[4],b__[4],c__,&s__[4],&c__);
  full_adder__B1(a__[5],b__[5],c__,&s__[5],&c__);
  full_adder__B1(a__[6],b__[6],c__,&s__[6],&c__);
  full_adder__B1(a__[7],b__[7],c__,&s__[7],&c__);
  full_adder__B1(a__[8],b__[8],c__,&s__[8],&c__);
  full_adder__B1(a__[9],b__[9],c__,&s__[9],&c__);
  full_adder__B1(a__[10],b__[10],c__,&s__[10],&c__);
  full_adder__B1(a__[11],b__[11],c__,&s__[11],&c__);
  full_adder__B1(a__[12],b__[12],c__,&s__[12],&c__);
  full_adder__B1(a__[13],b__[13],c__,&s__[13],&c__);
  full_adder__B1(a__[14],b__[14],c__,&s__[14],&c__);
  full_adder__B1(a__[15],b__[15],c__,&s__[15],&c__);

}

/* main function */
void add_32__ (/*inputs*/ DATATYPE a__[32],DATATYPE b__[32], /*outputs*/ DATATYPE s__[32]) {

  // Variables declaration
  DATATYPE c__;

  // Instructions (body)
  c__ = SET_ALL_ZERO();
  full_adder__B1(a__[0],b__[0],c__,&s__[0],&c__);
  full_adder__B1(a__[1],b__[1],c__,&s__[1],&c__);
  full_adder__B1(a__[2],b__[2],c__,&s__[2],&c__);
  full_adder__B1(a__[3],b__[3],c__,&s__[3],&c__);
  full_adder__B1(a__[4],b__[4],c__,&s__[4],&c__);
  full_adder__B1(a__[5],b__[5],c__,&s__[5],&c__);
  full_adder__B1(a__[6],b__[6],c__,&s__[6],&c__);
  full_adder__B1(a__[7],b__[7],c__,&s__[7],&c__);
  full_adder__B1(a__[8],b__[8],c__,&s__[8],&c__);
  full_adder__B1(a__[9],b__[9],c__,&s__[9],&c__);
  full_adder__B1(a__[10],b__[10],c__,&s__[10],&c__);
  full_adder__B1(a__[11],b__[11],c__,&s__[11],&c__);
  full_adder__B1(a__[12],b__[12],c__,&s__[12],&c__);
  full_adder__B1(a__[13],b__[13],c__,&s__[13],&c__);
  full_adder__B1(a__[14],b__[14],c__,&s__[14],&c__);
  full_adder__B1(a__[15],b__[15],c__,&s__[15],&c__);
  full_adder__B1(a__[16],b__[16],c__,&s__[16],&c__);
  full_adder__B1(a__[17],b__[17],c__,&s__[17],&c__);
  full_adder__B1(a__[18],b__[18],c__,&s__[18],&c__);
  full_adder__B1(a__[19],b__[19],c__,&s__[19],&c__);
  full_adder__B1(a__[20],b__[20],c__,&s__[20],&c__);
  full_adder__B1(a__[21],b__[21],c__,&s__[21],&c__);
  full_adder__B1(a__[22],b__[22],c__,&s__[22],&c__);
  full_adder__B1(a__[23],b__[23],c__,&s__[23],&c__);
  full_adder__B1(a__[24],b__[24],c__,&s__[24],&c__);
  full_adder__B1(a__[25],b__[25],c__,&s__[25],&c__);
  full_adder__B1(a__[26],b__[26],c__,&s__[26],&c__);
  full_adder__B1(a__[27],b__[27],c__,&s__[27],&c__);
  full_adder__B1(a__[28],b__[28],c__,&s__[28],&c__);
  full_adder__B1(a__[29],b__[29],c__,&s__[29],&c__);
  full_adder__B1(a__[30],b__[30],c__,&s__[30],&c__);
  full_adder__B1(a__[31],b__[31],c__,&s__[31],&c__);

}

/* Additional functions */


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 node full_adder(a :  b1 :: base,b :  b1 :: base,cin :  b1 :: base)
  returns s :  b1 :: base,cout :  b1 :: base
vars

let
(s) = ((a ^ b) ^ cin);
(cout) = ((a & b) ^ (cin & (a ^ b)))
tel

 node add_8(a :  b8 :: base,b :  b8 :: base)
  returns s :  b8 :: base
vars
  c :  b9 :: base
let
(c[0]) = 0;
_unroll forall i in [0,7] {
(s[i],c[(i + 1)]) = full_adder(a[i],b[i],c[i])
}
tel

 node add_16(a :  b16 :: base,b :  b16 :: base)
  returns s :  b16 :: base
vars
  c :  b17 :: base
let
(c[0]) = 0;
_unroll forall i in [0,15] {
(s[i],c[(i + 1)]) = full_adder(a[i],b[i],c[i])
}
tel

 node add_32(a :  b32 :: base,b :  b32 :: base)
  returns s :  b32 :: base
vars
  c :  b33 :: base
let
(c[0]) = 0;
_unroll forall i in [0,31] {
(s[i],c[(i + 1)]) = full_adder(a[i],b[i],c[i])
}
tel

*/
 