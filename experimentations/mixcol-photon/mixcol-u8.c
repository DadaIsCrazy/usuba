/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "experimentations/mixcol-photon/mixcol-u8.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 4
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */


/* main function */
void MixColumnSerial__ (/*inputs*/ DATATYPE X__[8], /*outputs*/ DATATYPE Y__[8]) {

  // Variables declaration
  DATATYPE step__V4_1__shadow_acc__1_;
  DATATYPE step__V4_1__shadow_acc__2_;
  DATATYPE step__V4_1__shadow_acc__3_;
  DATATYPE step__V4_1__shadow_acc__4_;
  DATATYPE step__V4_1__shadow_acc__5_;
  DATATYPE step__V4_1__shadow_acc__6_;
  DATATYPE step__V4_1__shadow_acc__7_;
  DATATYPE step__V4_1__tmp10_;
  DATATYPE step__V4_1__tmp11_;
  DATATYPE step__V4_1__tmp12_;
  DATATYPE step__V4_1__tmp6_;
  DATATYPE step__V4_1__tmp7_;
  DATATYPE step__V4_1__tmp8_;
  DATATYPE step__V4_1__tmp9_;
  DATATYPE step__V4_1_xtimes__V4_1__tmp3_;
  DATATYPE step__V4_1_xtimes__V4_1__tmp4_;
  DATATYPE step__V4_1_xtimes__V4_1_c__;
  DATATYPE step__V4_1_xtimes__V4_1_t__;
  DATATYPE step__V4_1_xtimes__V4_2__tmp3_;
  DATATYPE step__V4_1_xtimes__V4_2__tmp4_;
  DATATYPE step__V4_1_xtimes__V4_2_c__;
  DATATYPE step__V4_1_xtimes__V4_2_t__;
  DATATYPE step__V4_1_xtimes__V4_3__tmp3_;
  DATATYPE step__V4_1_xtimes__V4_3__tmp4_;
  DATATYPE step__V4_1_xtimes__V4_3_c__;
  DATATYPE step__V4_1_xtimes__V4_3_t__;
  DATATYPE x__[9][8];

  // Instructions (body)
  for (int i__ = 0; i__ <= 7; i__++) {
    x__[0][i__] = X__[i__];
  }
  for (int i__ = 0; i__ <= 7; i__++) {
    step__V4_1__shadow_acc__1_ = XOR(x__[i__][3],x__[i__][5]);
    x__[(i__ + 1)][0] = x__[i__][1];
    x__[(i__ + 1)][1] = x__[i__][2];
    x__[(i__ + 1)][2] = x__[i__][3];
    x__[(i__ + 1)][3] = x__[i__][4];
    x__[(i__ + 1)][4] = x__[i__][5];
    x__[(i__ + 1)][5] = x__[i__][6];
    x__[(i__ + 1)][6] = x__[i__][7];
    step__V4_1_xtimes__V4_1_t__ = L_SHIFT(step__V4_1__shadow_acc__1_,1,4);
    step__V4_1_xtimes__V4_1_c__ = R_SHIFT(step__V4_1__shadow_acc__1_,3,4);
    step__V4_1_xtimes__V4_1__tmp3_ = XOR(step__V4_1_xtimes__V4_1_t__,step__V4_1_xtimes__V4_1_c__);
    step__V4_1_xtimes__V4_1__tmp4_ = L_SHIFT(step__V4_1_xtimes__V4_1_c__,1,4);
    step__V4_1__shadow_acc__2_ = XOR(step__V4_1_xtimes__V4_1__tmp3_,step__V4_1_xtimes__V4_1__tmp4_);
    step__V4_1__tmp6_ = XOR(step__V4_1__shadow_acc__2_,x__[i__][1]);
    step__V4_1__tmp7_ = XOR(step__V4_1__tmp6_,x__[i__][6]);
    step__V4_1__shadow_acc__3_ = XOR(step__V4_1__tmp7_,x__[i__][7]);
    step__V4_1_xtimes__V4_2_t__ = L_SHIFT(step__V4_1__shadow_acc__3_,1,4);
    step__V4_1_xtimes__V4_2_c__ = R_SHIFT(step__V4_1__shadow_acc__3_,3,4);
    step__V4_1_xtimes__V4_2__tmp3_ = XOR(step__V4_1_xtimes__V4_2_t__,step__V4_1_xtimes__V4_2_c__);
    step__V4_1_xtimes__V4_2__tmp4_ = L_SHIFT(step__V4_1_xtimes__V4_2_c__,1,4);
    step__V4_1__shadow_acc__4_ = XOR(step__V4_1_xtimes__V4_2__tmp3_,step__V4_1_xtimes__V4_2__tmp4_);
    step__V4_1__tmp8_ = XOR(step__V4_1__shadow_acc__4_,x__[i__][0]);
    step__V4_1__tmp9_ = XOR(step__V4_1__tmp8_,x__[i__][2]);
    step__V4_1__tmp10_ = XOR(step__V4_1__tmp9_,x__[i__][3]);
    step__V4_1__tmp11_ = XOR(step__V4_1__tmp10_,x__[i__][4]);
    step__V4_1__shadow_acc__5_ = XOR(step__V4_1__tmp11_,x__[i__][7]);
    step__V4_1_xtimes__V4_3_t__ = L_SHIFT(step__V4_1__shadow_acc__5_,1,4);
    step__V4_1_xtimes__V4_3_c__ = R_SHIFT(step__V4_1__shadow_acc__5_,3,4);
    step__V4_1_xtimes__V4_3__tmp3_ = XOR(step__V4_1_xtimes__V4_3_t__,step__V4_1_xtimes__V4_3_c__);
    step__V4_1_xtimes__V4_3__tmp4_ = L_SHIFT(step__V4_1_xtimes__V4_3_c__,1,4);
    step__V4_1__shadow_acc__6_ = XOR(step__V4_1_xtimes__V4_3__tmp3_,step__V4_1_xtimes__V4_3__tmp4_);
    step__V4_1__tmp12_ = XOR(step__V4_1__shadow_acc__6_,x__[i__][3]);
    step__V4_1__shadow_acc__7_ = XOR(step__V4_1__tmp12_,x__[i__][6]);
    x__[(i__ + 1)][7] = step__V4_1__shadow_acc__7_;
  }
  Y__[0] = x__[8][0];
  Y__[1] = x__[8][1];
  Y__[2] = x__[8][2];
  Y__[3] = x__[8][3];
  Y__[4] = x__[8][4];
  Y__[5] = x__[8][5];
  Y__[6] = x__[8][6];
  Y__[7] = x__[8][7];

}


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 node xtimes(e :  u4 :: base)
  returns e' :  u4 :: base
vars
  t :  u4 :: base,
  c :  u4 :: base
let
  (t) = (e << 1);
  (c) = (e >> 3);
  (e') = (((t & 15) ^ c) ^ (c << 1))
tel

 node step(x :  u4[8] :: base)
  returns x' :  u4[8] :: base
vars
  acc :  u4 :: base
let
  (acc) = 0;
  (acc) := ((acc ^ x[3]) ^ x[5]);
  (acc) := xtimes(acc);
  (acc) := (((acc ^ x[1]) ^ x[6]) ^ x[7]);
  (acc) := xtimes(acc);
  (acc) := (((((acc ^ x[0]) ^ x[2]) ^ x[3]) ^ x[4]) ^ x[7]);
  (acc) := xtimes(acc);
  (acc) := ((acc ^ x[3]) ^ x[6]);
  (x') = (x[1 .. 7],acc)
tel

 node MixColumnSerial(X :  u4[8] :: base)
  returns Y :  u4[8] :: base
vars
  x :  u4[9][8] :: base,
  y :  u4[9] :: base
let
  forall i in [0,7] {
    (x[0][i]) = (X[i] & 15)
  };
  forall i in [0,7] {
    (x[(i + 1)]) = step(x[i])
  };
  (Y) = x[8]
tel

*/
 