/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "experimentations/mixcol-photon/mixcol.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */


/* main function */
void MixColumnSerial__ (/*inputs*/ DATATYPE X__, /*outputs*/ DATATYPE* Y__) {

  // Variables declaration
  DATATYPE _tmp13_;
  DATATYPE _tmp15_;
  DATATYPE step__V32_1__shadow_acc__1_;
  DATATYPE step__V32_1__shadow_acc__2_;
  DATATYPE step__V32_1__shadow_acc__3_;
  DATATYPE step__V32_1__shadow_acc__4_;
  DATATYPE step__V32_1__shadow_acc__5_;
  DATATYPE step__V32_1__shadow_acc__6_;
  DATATYPE step__V32_1__shadow_acc__7_;
  DATATYPE step__V32_1__tmp10_;
  DATATYPE step__V32_1__tmp11_;
  DATATYPE step__V32_1__tmp12_;
  DATATYPE step__V32_1__tmp6_;
  DATATYPE step__V32_1__tmp7_;
  DATATYPE step__V32_1__tmp8_;
  DATATYPE step__V32_1__tmp9_;
  DATATYPE step__V32_1_xtimes__V32_1__tmp2_;
  DATATYPE step__V32_1_xtimes__V32_1__tmp3_;
  DATATYPE step__V32_1_xtimes__V32_1__tmp4_;
  DATATYPE step__V32_1_xtimes__V32_1_c__;
  DATATYPE step__V32_1_xtimes__V32_1_t__;
  DATATYPE step__V32_1_xtimes__V32_2__tmp2_;
  DATATYPE step__V32_1_xtimes__V32_2__tmp3_;
  DATATYPE step__V32_1_xtimes__V32_2__tmp4_;
  DATATYPE step__V32_1_xtimes__V32_2_c__;
  DATATYPE step__V32_1_xtimes__V32_2_t__;
  DATATYPE step__V32_1_xtimes__V32_3__tmp2_;
  DATATYPE step__V32_1_xtimes__V32_3__tmp3_;
  DATATYPE step__V32_1_xtimes__V32_3__tmp4_;
  DATATYPE step__V32_1_xtimes__V32_3_c__;
  DATATYPE step__V32_1_xtimes__V32_3_t__;
  DATATYPE x__[9][8];
  DATATYPE y__;
  DATATYPE _tmp25_;
  DATATYPE _tmp24_;
  DATATYPE _tmp23_;
  DATATYPE _tmp22_;

  // Instructions (body)
  for (int i__ = 0; i__ <= 7; i__++) {
    _tmp13_ = R_SHIFT(X__,(28 - (i__ * 4)),32);
    _tmp22_ = LIFT_32(15);
    x__[0][i__] = AND(_tmp13_,_tmp22_);
  }
  for (int i__ = 0; i__ <= 7; i__++) {
    step__V32_1__shadow_acc__1_ = XOR(x__[i__][3],x__[i__][5]);
    x__[(i__ + 1)][0] = x__[i__][1];
    x__[(i__ + 1)][1] = x__[i__][2];
    x__[(i__ + 1)][2] = x__[i__][3];
    x__[(i__ + 1)][3] = x__[i__][4];
    x__[(i__ + 1)][4] = x__[i__][5];
    x__[(i__ + 1)][5] = x__[i__][6];
    x__[(i__ + 1)][6] = x__[i__][7];
    step__V32_1_xtimes__V32_1_t__ = L_SHIFT(step__V32_1__shadow_acc__1_,1,32);
    step__V32_1_xtimes__V32_1_c__ = R_SHIFT(step__V32_1__shadow_acc__1_,3,32);
    _tmp23_ = LIFT_32(15);
    step__V32_1_xtimes__V32_1__tmp2_ = AND(step__V32_1_xtimes__V32_1_t__,_tmp23_);
    step__V32_1_xtimes__V32_1__tmp4_ = L_SHIFT(step__V32_1_xtimes__V32_1_c__,1,32);
    step__V32_1_xtimes__V32_1__tmp3_ = XOR(step__V32_1_xtimes__V32_1__tmp2_,step__V32_1_xtimes__V32_1_c__);
    step__V32_1__shadow_acc__2_ = XOR(step__V32_1_xtimes__V32_1__tmp3_,step__V32_1_xtimes__V32_1__tmp4_);
    step__V32_1__tmp6_ = XOR(step__V32_1__shadow_acc__2_,x__[i__][1]);
    step__V32_1__tmp7_ = XOR(step__V32_1__tmp6_,x__[i__][6]);
    step__V32_1__shadow_acc__3_ = XOR(step__V32_1__tmp7_,x__[i__][7]);
    step__V32_1_xtimes__V32_2_t__ = L_SHIFT(step__V32_1__shadow_acc__3_,1,32);
    step__V32_1_xtimes__V32_2_c__ = R_SHIFT(step__V32_1__shadow_acc__3_,3,32);
    _tmp24_ = LIFT_32(15);
    step__V32_1_xtimes__V32_2__tmp2_ = AND(step__V32_1_xtimes__V32_2_t__,_tmp24_);
    step__V32_1_xtimes__V32_2__tmp4_ = L_SHIFT(step__V32_1_xtimes__V32_2_c__,1,32);
    step__V32_1_xtimes__V32_2__tmp3_ = XOR(step__V32_1_xtimes__V32_2__tmp2_,step__V32_1_xtimes__V32_2_c__);
    step__V32_1__shadow_acc__4_ = XOR(step__V32_1_xtimes__V32_2__tmp3_,step__V32_1_xtimes__V32_2__tmp4_);
    step__V32_1__tmp8_ = XOR(step__V32_1__shadow_acc__4_,x__[i__][0]);
    step__V32_1__tmp9_ = XOR(step__V32_1__tmp8_,x__[i__][2]);
    step__V32_1__tmp10_ = XOR(step__V32_1__tmp9_,x__[i__][3]);
    step__V32_1__tmp11_ = XOR(step__V32_1__tmp10_,x__[i__][4]);
    step__V32_1__shadow_acc__5_ = XOR(step__V32_1__tmp11_,x__[i__][7]);
    step__V32_1_xtimes__V32_3_t__ = L_SHIFT(step__V32_1__shadow_acc__5_,1,32);
    step__V32_1_xtimes__V32_3_c__ = R_SHIFT(step__V32_1__shadow_acc__5_,3,32);
    _tmp25_ = LIFT_32(15);
    step__V32_1_xtimes__V32_3__tmp2_ = AND(step__V32_1_xtimes__V32_3_t__,_tmp25_);
    step__V32_1_xtimes__V32_3__tmp4_ = L_SHIFT(step__V32_1_xtimes__V32_3_c__,1,32);
    step__V32_1_xtimes__V32_3__tmp3_ = XOR(step__V32_1_xtimes__V32_3__tmp2_,step__V32_1_xtimes__V32_3_c__);
    step__V32_1__shadow_acc__6_ = XOR(step__V32_1_xtimes__V32_3__tmp3_,step__V32_1_xtimes__V32_3__tmp4_);
    step__V32_1__tmp12_ = XOR(step__V32_1__shadow_acc__6_,x__[i__][3]);
    step__V32_1__shadow_acc__7_ = XOR(step__V32_1__tmp12_,x__[i__][6]);
    x__[(i__ + 1)][7] = step__V32_1__shadow_acc__7_;
  }
  y__ = LIFT_32(0);
  for (int i__ = 0; i__ <= 7; i__++) {
    _tmp15_ = L_SHIFT(y__,4,32);
    y__ = OR(_tmp15_,x__[8][i__]);
  }
  *Y__ = y__;

}


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 node xtimes(e :  u32 :: base)
  returns e' :  u32 :: base
vars
  t :  u32 :: base,
  c :  u32 :: base
let
  (t) = (e << 1);
  (c) = (e >> 3);
  (e') = (((t & 15) ^ c) ^ (c << 1))
tel

 node step(x :  u32[8] :: base)
  returns x' :  u32[8] :: base
vars
  acc :  u32 :: base
let
  (acc) = 0;
  (acc) := ((acc ^ x[3]) ^ x[5]);
  (acc) := xtimes(acc);
  (acc) := (((acc ^ x[1]) ^ x[6]) ^ x[7]);
  (acc) := xtimes(acc);
  (acc) := (((((acc ^ x[0]) ^ x[2]) ^ x[3]) ^ x[4]) ^ x[7]);
  (acc) := xtimes(acc);
  (acc) := ((acc ^ x[3]) ^ x[6]);
  (x') = (x[1 .. 7],acc)
tel

 node MixColumnSerial(X :  u32 :: base)
  returns Y :  u32 :: base
vars
  x :  u32[9][8] :: base,
  y :  u32[9] :: base
let
  forall i in [0,7] {
    (x[0][i]) = ((X >> (28 - (i * 4))) & 15)
  };
  forall i in [0,7] {
    (x[(i + 1)]) = step(x[i])
  };
  (y[0]) = 0;
  forall i in [0,7] {
    (y[(i + 1)]) = ((y[i] << 4) | x[8][i])
  };
  (Y) = y[8]
tel

*/
 