* Tasks
** DONE Basic parser/lexer
   CLOSED: [2017-02-14 mar. 09:51]
** DONE AST pretty-printer
   CLOSED: [2017-02-14 mar. 09:51]
** DONE Kwan's 4th S-box
   CLOSED: [2017-02-14 mar. 09:51]
** DONE Fix the reduce/reduce conflicts of the parser.
   CLOSED: [2017-02-14 mar. 09:51]
** DONE Implement merge
   CLOSED: [2017-02-14 mar. 15:37]
*** DONE Fix merge conflicts
    CLOSED: [2017-02-14 mar. 15:37]
** DONE Remove useless abstraction in the AST (ex: type pat = AST_pat of ident list)
   CLOSED: [2017-02-14 mar. 10:45]
** DONE Add line/column number to errors
   CLOSED: [2017-02-14 mar. 15:53]
** DONE Add a few detailed examples
   CLOSED: [2017-02-14 mar. 16:20]
** DONE Generate OCaml code (string concatenation)
   CLOSED: [2017-02-15 mer. 10:50]
** DONE Implement generation of multiplexeur
   CLOSED: [2017-02-15 mer. 11:52]
** DONE Modify parser/lexer to use boolean as base type
   CLOSED: [2017-02-15 mer. 11:52]
** DONE Verify that the logical s-box is indeed equivalent to the lookup table 
   CLOSED: [2017-02-15 mer. 16:21]
** DONE Convert data to bitsliced format.
   CLOSED: [2017-02-16 jeu. 16:01]
** DONE Complete the DES implementation (at least 1 round)
   CLOSED: [2017-02-16 jeu. 18:48]
** DONE Implement a standart DES
   CLOSED: [2017-02-21 mar. 10:33]
*** DONE The implementation of the key scheduling is weird, need to figure it out. 
    CLOSED: [2017-02-21 mar. 10:15]
*** DONE Implement ECB
    CLOSED: [2017-02-21 mar. 11:59]
*** TODO Implement CBC
*** DONE Implement CFB
    CLOSED: [2017-02-21 mar. 17:30]
*** DONE Implement OFB
    CLOSED: [2017-02-21 mar. 18:21]
** DONE Add variable uint_n (with n an integer) notation.
   CLOSED: [2017-02-21 mar. 18:55]
** DONE Add variables declaration at the begining of nodes
   CLOSED: [2017-02-22 mer. 10:14]
** DONE Add dotted notation (x.n) to access bits of an integer.
   CLOSED: [2017-02-22 mer. 10:14]
** DONE Add AST transformation for naive ocaml backend
   CLOSED: [2017-02-22 mer. 15:39]
** DONE Convert variables names.
   CLOSED: [2017-02-22 mer. 15:59]
   That's because notations like x.1 generates a variable x1, which can conflict with
   a user-defined variable.
** DONE Allow operators to work on tuples.
   CLOSED: [2017-02-22 mer. 17:41]
   Concrecly, it means allowing to write "a xor b" instead of "a.1 xor b.1; ... ; a.n xor b.n"
** DONE Improve projections.
   CLOSED: [2017-02-23 jeu. 17:50]
   say we have =s1: intn -> int4= and =s2: intn -> int4=
   and =permut: int8 -> intk=
   if we do =permut(s1(...),s2(...))=
   then, the translation to OCaml results in a call looking like =permut(...,...)=,
   ie, =permut: int4 * int4 -> intk=, which is in conflict with =permut: int8 -> intk=
   To solve this, a function =convert: int4 -> int4 -> int8= sould be automatically generated,
   so the OCaml code should look like =permut(convert(s1(...),s2(...))=.
   From this, it will be easy to have n-ary operators.
** DONE Fix operators on tuple
   CLOSED: [2017-02-24 ven. 10:23]
** DONE Implement fby on boolean backend
   CLOSED: [2017-02-25 sam. 20:19]
** DONE Think about how to actually run usuba code (orthogonalization + streams & co), naive.
   CLOSED: [2017-02-25 sam. 20:20]
** TODO Generate bitsliced code from usuba code.
** TODO Don't generate several times the same "convert" function
** TODO Regroup env_var and env_fun into a single env, add helpers to manipulate it
** TODO Complete implementation of usuba DES
** TODO Improve orthogonalization algorithm
** TODO [#B] Think about the convertion of the demultiplexer to OCaml.
   in particular, for now, I change True to 1 and False to 0. 
   This might not work in the future.
** TODO [#B] Get familiar with [[https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/][ppx]], parsetree, and co.
*** TODO [#C] Improve pretty printing (with [[http://gallium.inria.fr/blog/first-release-of-pprint/][Ocaml PPrint]] eventually)
** TODO Learn org-mode!


* Examples

Note ([2017-02-22 mer.]) : uint_n types have been added, a "vars" section must be 
at the begining of every node, and a few syntaxic modifications have been done over
the past few days. Therefore, some of the following examples might not work on the 
current version. I'll fix that as soon as I can.


** Compilation (parsing, generating OCaml code...)

The program main.native parses a file, creates an AST, print this AST (which looks 
quite like the original program), and generates the OCaml code corresponding to it.
#+BEGIN_SRC bash
    cd src
    make
    ./main.native tests/simple_node.prog      # just a basic program
    ./main.native tests/simple_when.prog      # a simple when
    ./main.native tests/simple_merge.prog     # a simple merge
    ./main.native tests/s-box-4.prog          # Kwan's 4th s-box
    ./main.native tests/nested_merge.prog     # a nested merge (to make sure the 
                                              # parser works fine on those)
    ./main.native tests/multiple_nodes.prog   # definition of multiple nodes. 
    ./main.native tests/complete_prog_1.prog  # a slightly more complex program
#+END_SRC

** DES

A bitsliced implementation of the first round of DES is in src/tests/des.prog.
Run =./main.native tests/des.prog= to generate the des.ml inside src/tests/ocaml_run .
You can then compile it with =ocamlopt ocaml_runtime.ml des.ml -o des= 
(ocaml_runtime.ml contains a few functions (just one for now) needed to run the
generated programs).


** Equivalence of the lookup based and logical gate based s-box

A standart (ie. with a lookup table) implementation of the 4-th S-box, as well as a
logical one, generated with the command =./main.native tests/s-box-4.prog= are available
in the file =src/tests/verif_sbox.ml= .
It allows you to check that both implementations are equivalent: you just need to run
=ocaml src/tests/verif_sbox.ml=

** Standart DES implementation

A standart implementation of DES is available (file =src/des/des.ml=). This file includes
a few test to verify the correctness of the code. This tests consists in encrypting 2 blocks,
then decrypting them. If the code is correct, this should be equivalent to the identity.
To run those tests:
#+BEGIN_SRC bash
    cd src/des
    ocamlc -o des des.ml
    ./des
#+END_SRC

You'll see that each test yields the same result, that's a good sign.


* Notes

** A tuple has necessary at least 2 elements. 
First, a tuple of 1 element is just a variable (this element). Secondly, it's easier to parse.

** By convention, the =main= is the last node declared.
(this might change in the future, but it's easier to do this for now)
